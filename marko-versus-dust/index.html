<!doctype html> <html lang="en"> <head><meta http-equiv="Content-Type" content="text/html" charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Marko versus Dust | Patrick Steele-Idem</title><link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml"><meta name="description" content="Web Development, JavaScript, Node.js and open source software."><link href="/favicon.ico" rel="icon"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width"><link rel="stylesheet" type="text/css" href="/static/post-78f5e532.css">
<link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css"></head><body><div id="header-bg"></div><div id="nav-bg"></div><div id="content"><header id="header"><div id="titles"><h1><a href="/">Patrick Steele-Idem</a></h1><h2>Better WebDev</h2></div></header><nav role="navigation" id="nav"><ul class="main-navigation"><li><a href="/">Blog</a></li><li><a href="/archive/">Archive</a></li><li><a href="/about/">About</a></li><li><a href="/subscribe/">Subscribe</a></li><li><form action="https://google.com/search" method="get" class="search-form"><fieldset role="search"><input type="hidden" name="q" value="site:http://psteeleidem.com/"><input type="text" name="q" results="0" placeholder="Search" class="search-input"></fieldset></form></li></ul></nav><main id="main"><article class="hentry" role="article"><h1 class="post-title">Marko versus Dust</h1><div class="post-meta"><span class="byline author vcard">Posted by <span class="fn">Patrick Steele-Idem</span></span> on <time data-updated="true" pubdate="" datetime="2014-10-22">Wednesday, Oct 22nd, 2014</time> <span class="categories">&nbsp; <nobr><i class="fa fa-tags"></i> <a href="/category/dust/" class="category">Dust</a>, <a href="/category/javascript/" class="category">JavaScript</a>, <a href="/category/marko/" class="category">Marko</a>, <a href="/category/templating/" class="category">Templating</a></nobr></span></div><div class="post-body"><p>This guide aims to compare <a href="https://github.com/raptorjs/marko">Marko</a> and <a href="https://github.com/linkedin/dustjs">Dust</a> to help guide developers deciding between the two. However, even if you are considering other templating languages, such as Handlebars or Mustache, this guide should still be helpful.</p>
<p>Why Marko and Dust? Dust represents a well-established text-based templating language and Marko represents a well-established HTML-based templating language. Marko was created as an alternative to Dust when Dust was first starting to be used at eBay.</p>
<p><em>Disclaimer: This guide is my opinion, and as the author of Marko it is very difficult for me to be unbiased. Also, I&#39;ve used Dust enough to be proficient in it, but I would not claim to be a Dust expert. If you feel that anything is misleading or wrong then please let me know and I will correct it. Also, my goal was to be as objective and as fair as possible, but some things are inherently subjective.</em></p>
<p><p class="toc"><strong>Table of Contents</strong><ul class="toc-level0"><li><a href="#design-philosophies">Design Philosophies</a><ul class="toc-level1"><li><a href="#marko">Marko</a></li><li><a href="#dust">Dust</a></li></ul></li><li><a href="#feature-comparison">Feature Comparison</a><ul class="toc-level1"><li><a href="#language">Language</a></li><li><a href="#runtime">Runtime</a></li><li><a href="#compiler">Compiler</a></li><li><a href="#performance">Performance</a></li><li><a href="#debugging">Debugging</a></li><li><a href="#extensibility">Extensibility</a></li><li><a href="#interoperability">Interoperability</a></li><li><a href="#community">Community</a></li></ul></li><li><a href="#code-comparison">Code Comparison</a><ul class="toc-level1"><li><a href="#dynamic-text">Dynamic Text</a></li><li><a href="#looping">Looping</a><ul class="toc-level2"><li><a href="#loop-status-variable">Loop Status Variable</a></li></ul></li><li><a href="#conditionals">Conditionals</a></li><li><a href="#template-inheritance">Template Inheritance</a></li><li><a href="#custom-tags">Custom Tags</a></li></ul></li><li><a href="#detailed-comparisons">Detailed Comparisons</a><ul class="toc-level1"><li><a href="#overview">Overview</a></li><li><a href="#readability">Readability</a></li><li><a href="#ramp-up-time">Ramp-up Time</a></li><li><a href="#javascript-api-usability">JavaScript API Usability</a></li><li><a href="#dry">DRY</a></li><li><a href="#asynchronous-and-streaming-support">Asynchronous and Streaming Support</a></li><li><a href="#interoperability-1">Interoperability</a></li><li><a href="#extensibility-1">Extensibility</a></li><li><a href="#rendering-performance">Rendering Performance</a></li><li><a href="#page-weight">Page Weight</a></li><li><a href="#ease-of-debugging">Ease of Debugging</a></li><li><a href="#security">Security</a></li><li><a href="#validation">Validation</a></li><li><a href="#editor-support">Editor Support</a></li><li><a href="#community-1">Community</a></li><li><a href="#maturity">Maturity</a></li><li><a href="#documentation">Documentation</a></li><li><a href="#future-relevancy">Future Relevancy</a></li></ul></li><li><a href="#summary">Summary</a></li></ul></p></p>
<style type="text/css">
.compare {
    margin-top: 1.1em;
    margin-bottom: 1.1em;
    width: 100%;
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;

}

.compare h1 {
    margin-top: 0.1em;
    margin-bottom: 0.1em;
    font-size: 1.2em;
}

.compare:after {
    content: "";
    display: table;
    clear: both;
}

.compare div {
    padding: 0.5em;
    border: 1px solid #c0c0c0;
    float: left;
    width: 49%;
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}

.compare .col1 {
    margin-right: 1%;
    background-color: #f8f8f8;
}

.compare .col2 {
    margin-left: 1%;
    background-color: #f8f8f8;
}

.compare ul {
    margin-left: 1em;
}

.compare .good {

}

.compare .decent {

}

.compare .bad {

}

/* Tiny Screens */
@media only screen and (max-width: 767px) {
    .compare div {
        padding: 0.4em;
        border: 1px solid #c0c0c0;
        float: none;
        width: auto;
        -webkit-box-sizing: border-box;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
    }

    .compare .col2 {
        margin-right: 0;
        margin-bottom: 1em;
    }

    .compare .col1 {
        margin-left: 0;
    }
}
</style>

<h2 id="design-philosophies"><a name="design-philosophies" class="anchor" href="#design-philosophies"><span class="header-link"></span></a>Design Philosophies</h2><p>Before we go into the features of each templating language, let&#39;s take a look at the design philosophies that helped shape each language.</p>
<h3 id="marko"><a name="marko" class="anchor" href="#marko"><span class="header-link"></span></a>Marko</h3><ul>
<li><strong>Readable:</strong> Templates should be as close to the output HTML as possible to keep templates readable. Cryptic syntax and symbols should be avoided.</li>
<li><strong>Simple:</strong> The number of new concepts should be minimized and complexity should be avoided.</li>
<li><strong>Extensible:</strong> The template engine should be easily extensible at both compile-time and runtime.</li>
<li><strong>High Performance:</strong> Runtime and compiled output should be optimized for low CPU and memory usage and have a small footprint. All expressions should be native JavaScript to avoid runtime interpretation.</li>
<li><strong>Not Restrictive:</strong> Whether or not to go less logic or more logic is up to the developer.</li>
<li><strong>Asynchronous and Streaming Output:</strong> It should be possible to render HTML out-of-order, but the output HTML should be streamed out in the correct order. This minimizes idle time and reduces the time to first byte.</li>
<li><strong>Intuitive:</strong> The templating engine should introduce as few surprises as possible.</li>
<li><strong>Browser and Server Compatibility:</strong> Templates should compile down to JavaScript that can be executed on both the server and the client.</li>
<li><strong>Debuggable:</strong> Compiled JavaScript should be debuggable and readable.</li>
<li><strong>Compile-Time Checks:</strong> Syntax, custom tags and custom attributes should be validated at compile-time.</li>
<li><strong>Tools Support:</strong> Tools should be enabled to offer auto-completion and validation for improved productivity and safety.</li>
<li><strong>Modular:</strong> Runtime and compiled templates should be based on CommonJS modules for improved dependency management. Template dependencies (such as custom tags) should be resolved based on a template&#39;s file system path instead of relying on a shared registry.</li>
</ul>
<h3 id="dust"><a name="dust" class="anchor" href="#dust"><span class="header-link"></span></a>Dust</h3><p><em>From the original author of Dust:</em></p>
<ul>
<li><strong>Markup-like:</strong> A templating syntax should not encompass operations that are better left to a programming language. Templates should make it easy to format content for presentation while keeping application logic where it belongs: in the application.</li>
<li><strong>Asynchronous:</strong> Template helpers should be callable asynchronously and in parallel so that expensive operations (caching, deferred loading, filtering) can run as the template is being rendered.</li>
<li><strong>Streaming:</strong> Templates should allow (but not require) data to be flushed to the output in user-defined chunks.</li>
<li><strong>Browser and server compatible:</strong> Templates should render in both server and browser environments without hacks or extensive configuration.</li>
<li><strong>Storage agnostic:</strong> The templating engine should not impose a particular loading scheme. Developers should be free to load templates via the filesystem, a database or an army of carrier pigeons.</li>
<li><strong>Composable:</strong> Designers should be able to break presentation markup into manageable components and combine these components at runtime. It should not be necessary to statically link templates or manually assemble &#39;layouts&#39; inside application code.</li>
<li><strong>Format agnostic:</strong> While HTML generation and DOM manipulation are useful in specific instances, a general-purpose template system should not be tied to a particular output format.</li>
<li><strong>Precise:</strong> The parser should be accurate enough that designers rarely have to use escape sequences to achieve the desired result. Similarly, templates shouldn&#39;t mysteriously generate or eliminate whitespace.</li>
<li><strong>Safe(r):</strong> At the very least, the engine should be configurable such that it is reasonably safe to render untrusted templates in a server environment.</li>
<li><strong>Fast:</strong> Server-side templates cannot always be cached. Browser-side templates may be rendered on devices with limited system resources. A template engine should be fast enough to render in real time without bottlenecking its environment.</li>
</ul>
<h2 id="feature-comparison"><a name="feature-comparison" class="anchor" href="#feature-comparison"><span class="header-link"></span></a>Feature Comparison</h2><h3 id="language"><a name="language" class="anchor" href="#language"><span class="header-link"></span></a>Language</h3><table class="markdown-table"><thead><tr>
<th></th>
<th>Marko</th>
<th>Dust</th>
</tr>
</thead><tbody><tr>
<td>Syntax</td>
<td>HTML syntax</td>
<td>Proprietary symbol-based syntax</td>
</tr>
<tr>
<td>Data referencing</td>
<td>JavaScript expressions</td>
<td>Simple paths</td>
</tr>
<tr>
<td>Data passing</td>
<td>Simple JavaScript objects</td>
<td>Custom Dust wrapper objects with hierarchical data lookup methods</td>
</tr>
<tr>
<td>Variable scoping</td>
<td>JavaScript closures and local variables</td>
<td>Push/pop/rebase data contexts</td>
</tr>
<tr>
<td>Conditionals</td>
<td>JavaScript expressions</td>
<td>Truthy/falsey test with alternate negated test</td>
</tr>
<tr>
<td>if…else-if…else</td>
<td>✔</td>
<td>if…else only</td>
</tr>
<tr>
<td>Simple ternary conditionals</td>
<td>✔</td>
<td>✖</td>
</tr>
<tr>
<td>Loop iteration data</td>
<td>Named JavaScript variable</td>
<td>Pushed data context</td>
</tr>
<tr>
<td>Loop status variable</td>
<td>index, length, isLast and isFirst</td>
<td>index and length</td>
</tr>
<tr>
<td>Loop separator</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>Custom loop iterators</td>
<td>✔</td>
<td>✖</td>
</tr>
<tr>
<td>Declare variables in template</td>
<td>✔</td>
<td>✖</td>
</tr>
<tr>
<td>Embed JavaScript</td>
<td>✔</td>
<td>✖</td>
</tr>
<tr>
<td>Simple function calls</td>
<td>✔ (JavaScript expressions)</td>
<td>✖</td>
</tr>
<tr>
<td>Auto-escaping</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>Template inheritance</td>
<td>✔ (<a href="https://github.com/raptorjs/marko#layout-taglib">layout taglib</a>)</td>
<td>✔</td>
</tr>
<tr>
<td>Macros</td>
<td>✔</td>
<td>✔ (inline partials)</td>
</tr>
<tr>
<td>Includes/Partials</td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody></table><h3 id="runtime"><a name="runtime" class="anchor" href="#runtime"><span class="header-link"></span></a>Runtime</h3><table class="markdown-table"><thead><tr>
<th></th>
<th>Marko</th>
<th>Dust</th>
</tr>
</thead><tbody><tr>
<td>Asynchronous fragments</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>Async fragment timeouts</td>
<td>✔</td>
<td>✖</td>
</tr>
<tr>
<td>Streaming</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>Output format</td>
<td>Text</td>
<td>Text</td>
</tr>
</tbody></table><h3 id="compiler"><a name="compiler" class="anchor" href="#compiler"><span class="header-link"></span></a>Compiler</h3><table class="markdown-table"><thead><tr>
<th></th>
<th>Marko</th>
<th>Dust</th>
</tr>
</thead><tbody><tr>
<td>Compiled output format</td>
<td>CommonJS module</td>
<td>Self-executing function that registers a named template (depends on a global <code>dust</code> variable)</td>
</tr>
<tr>
<td>Compile-time checks</td>
<td>Validate allowed attributes</td>
<td>Syntax check only</td>
</tr>
<tr>
<td>Compilation error reporting</td>
<td>Filename, column and line number and error message</td>
<td>Column and line number and error message</td>
</tr>
<tr>
<td>Compiled conditionals</td>
<td>Native JavaScript <code>if</code></td>
<td>Interpreted</td>
</tr>
<tr>
<td>Compiled looping</td>
<td>Native JavaScript <code>forEach</code> or <code>for</code></td>
<td>Interpreted</td>
</tr>
<tr>
<td>Compiled body blocks</td>
<td>JavaScript function</td>
<td>JavaScript function</td>
</tr>
<tr>
<td>Command-line compiler</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>Precompile templates for server</td>
<td>✔</td>
<td>Custom loader code required</td>
</tr>
<tr>
<td>Precompile templates for client</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>Whitespace Suppression</td>
<td>✔ (based on HTML structure)</td>
<td>✔ (based on text)</td>
</tr>
</tbody></table><h3 id="performance"><a name="performance" class="anchor" href="#performance"><span class="header-link"></span></a>Performance</h3><table class="markdown-table"><thead><tr>
<th></th>
<th>Marko</th>
<th>Dust</th>
</tr>
</thead><tbody><tr>
<td>CPU usage</td>
<td>Fastest*</td>
<td>Between 25% and 77% slower*</td>
</tr>
<tr>
<td>Compiled template size</td>
<td>Smallest*</td>
<td>Between 2% and 36% larger*</td>
</tr>
<tr>
<td>Runtime size</td>
<td>Smallest (~2.33KB)*</td>
<td>Larger (~3.41KB minimum, or ~4.7KB with optional <a href="https://github.com/linkedin/dustjs-helpers">helpers</a>)*</td>
</tr>
</tbody></table><p>*<a href="https://github.com/raptorjs/templating-benchmarks">See templating benchmarks</a></p>
<h3 id="debugging"><a name="debugging" class="anchor" href="#debugging"><span class="header-link"></span></a>Debugging</h3><table class="markdown-table"><thead><tr>
<th></th>
<th>Marko</th>
<th>Dust</th>
</tr>
</thead><tbody><tr>
<td>Stack traces on server</td>
<td>Valid stack traces and file paths</td>
<td>Source code not written to disk</td>
</tr>
<tr>
<td>Readable compiled output?</td>
<td>✔</td>
<td>✖</td>
</tr>
</tbody></table><h3 id="extensibility"><a name="extensibility" class="anchor" href="#extensibility"><span class="header-link"></span></a>Extensibility</h3><table class="markdown-table"><thead><tr>
<th></th>
<th>Marko</th>
<th>Dust</th>
</tr>
</thead><tbody><tr>
<td>Custom tags</td>
<td>✔ (HTML tags)</td>
<td>✔ (Dust helper tags)</td>
</tr>
<tr>
<td>Custom HTML attributes</td>
<td>✔</td>
<td>N/A</td>
</tr>
<tr>
<td>Custom tag signature</td>
<td><code>function(input, out)</code></td>
<td><code>function(chunk, context, bodies, params)</code></td>
</tr>
<tr>
<td>Custom compile-time transformations</td>
<td>✔ (pseudo DOM API for transforming AST)</td>
<td>✖ (not well-supported)</td>
</tr>
<tr>
<td>Custom compile-time code generation</td>
<td>✔ (custom AST nodes)</td>
<td>✖ (not well-supported)</td>
</tr>
<tr>
<td>Import vanilla Node.js modules as helpers?</td>
<td>✔</td>
<td>✖</td>
</tr>
<tr>
<td>Custom helper registration</td>
<td>Auto discovered (including taglibs installed using <a href="https://www.npmjs.org/">npm</a>)</td>
<td>Application code required<br>Example: <code>require(&#39;dustjs-helpers&#39;)</code></td>
</tr>
<tr>
<td>Declarative taglibs</td>
<td>✔</td>
<td>✖</td>
</tr>
</tbody></table><h3 id="interoperability"><a name="interoperability" class="anchor" href="#interoperability"><span class="header-link"></span></a>Interoperability</h3><table class="markdown-table"><thead><tr>
<th></th>
<th>Marko</th>
<th>Dust</th>
</tr>
</thead><tbody><tr>
<td>Package manager</td>
<td>npm</td>
<td>npm or pre-built distribution</td>
</tr>
<tr>
<td>Node.js support</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>Node.js-compatible module loader required?</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Client-side support</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td><a href="https://github.com/substack/node-browserify">Browserify</a> support</td>
<td>✔ (see <a href="https://github.com/raptorjs/markoify">markoify</a>)</td>
<td>Maybe (see <a href="https://github.com/blai/dust-browserify">dust-browserify</a>)</td>
</tr>
<tr>
<td><a href="https://github.com/raptorjs/optimizer">RaptorJS Optimizer</a> support</td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody></table><h3 id="community"><a name="community" class="anchor" href="#community"><span class="header-link"></span></a>Community</h3><table class="markdown-table"><thead><tr>
<th></th>
<th>Marko</th>
<th>Dust</th>
</tr>
</thead><tbody><tr>
<td>Original author</td>
<td><a href="https://github.com/patrick-steele-idem">Patrick Steele-Idem</a> (eBay)</td>
<td><a href="https://github.com/akdubya">Aleksander Williams</a> (no longer active)</td>
</tr>
<tr>
<td>Primary maintainers</td>
<td>eBay</td>
<td>eBay and LinkedIn</td>
</tr>
<tr>
<td>Source code</td>
<td><a href="https://github.com/raptorjs/marko">Github</a></td>
<td><a href="https://github.com/linkedin/dustjs">Github</a></td>
</tr>
<tr>
<td>Bugs and Feature Requests</td>
<td><a href="https://github.com/raptorjs/marko/issues">Github Issues</a></td>
<td><a href="https://github.com/linkedin/dustjs/issues">Github Issues</a></td>
</tr>
<tr>
<td>npm</td>
<td><a href="https://www.npmjs.org/package/marko">marko</a></td>
<td><a href="https://www.npmjs.org/package/dustjs-linkedin">dustjs-linkedin</a></td>
</tr>
<tr>
<td>Support Forums</td>
<td><a href="https://groups.google.com/forum/#!forum/raptorjs">Google Group</a></td>
<td><a href="http://stackoverflow.com/questions/tagged/dust.js">Stack Overflow</a></td>
</tr>
</tbody></table><h2 id="code-comparison"><a name="code-comparison" class="anchor" href="#code-comparison"><span class="header-link"></span></a>Code Comparison</h2><h3 id="dynamic-text"><a name="dynamic-text" class="anchor" href="#dynamic-text"><span class="header-link"></span></a>Dynamic Text</h3><p><strong>Marko</strong></p>
<pre><code class="lang-html">Hello $name!

<span class="hljs-comment">&lt;!-- Unescaped: --&gt;</span>
$!profile
</code></pre>
<p><strong>Dust:</strong></p>
<pre><code class="lang-html">Hello {name}!

{! Unescaped: !}
{profile|s}
</code></pre>
<h3 id="looping"><a name="looping" class="anchor" href="#looping"><span class="header-link"></span></a>Looping</h3><p><strong>Marko</strong></p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">for</span>=<span class="hljs-value">"friend in friends"</span>&gt;</span>
        $friend.name
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<p><strong>Dust:</strong></p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
    {#friends}
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>
        {name}
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    {/friends}
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<h4 id="loop-status-variable"><a name="loop-status-variable" class="anchor" href="#loop-status-variable"><span class="header-link"></span></a>Loop Status Variable</h4><p><strong>Marko</strong></p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">for</span>=<span class="hljs-value">"friend in friends; status-var=loop"</span>&gt;</span>
        ${loop.getIndex() + 1} of ${loop.getLength()}) $friend.name
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<p><strong>Dust:</strong></p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
    {#friends}
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>
        {@math key="{$idx}" method="add" operand="1" /} of {$len}) {name}
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    {/friends}
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<p>Output:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>
        1 of 3) Frank
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>
        2 of 3) John
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>
        3 of 3) Jane
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<h3 id="conditionals"><a name="conditionals" class="anchor" href="#conditionals"><span class="header-link"></span></a>Conditionals</h3><p><strong>Marko</strong></p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">if</span>=<span class="hljs-value">"isLoggedIn"</span>&gt;</span>
    Welcome back, ${name}!
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"balance {?balance&lt;0;negative;positive}"</span>&gt;</span>
    ${formattedBalance}
<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
</code></pre>
<p><strong>Dust:</strong></p>
<pre><code class="lang-html">{#isLoggedIn}
&lt;div&gt;
    Welcome back, {name}!
&lt;/div&gt;
{/isLoggedIn}

&lt;span class="balance {@if cond="{balance} &lt; 0"}negative{:else}positive{/if}"&gt;
    ${formattedBalance}
&lt;/span&gt;
</code></pre>
<h3 id="template-inheritance"><a name="template-inheritance" class="anchor" href="#template-inheritance"><span class="header-link"></span></a>Template Inheritance</h3><p><strong>Marko - base template:</strong></p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">layout-placeholder</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"title"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">layout-placeholder</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"body"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>
</code></pre>
<p><strong>Marko - child template:</strong></p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">layout-use</span> <span class="hljs-attribute">template</span>=<span class="hljs-value">"../layouts/base-template.marko"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">layout-put</span> <span class="hljs-attribute">into</span>=<span class="hljs-value">"title"</span>&gt;</span>
        Child Title
    <span class="hljs-tag">&lt;/<span class="hljs-title">layout-put</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">layout-put</span> <span class="hljs-attribute">into</span>=<span class="hljs-value">"body"</span>&gt;</span>
        Child Content
    <span class="hljs-tag">&lt;/<span class="hljs-title">layout-put</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">layout-use</span>&gt;</span>
</code></pre>
<hr/>

<p><strong>Dust - base template:</strong></p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">html</span> <span class="hljs-attribute">lang</span>=<span class="hljs-value">"en"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>{+title/}<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
        {+body/}
    <span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>
</code></pre>
<p><strong>Dust - child template:</strong></p>
<pre><code class="lang-html">{&gt;layouts/base-template}
{&lt;title}
    Child Title
{/title}
{&lt;body}
    Child Content
{/body}
</code></pre>
<h3 id="custom-tags"><a name="custom-tags" class="anchor" href="#custom-tags"><span class="header-link"></span></a>Custom Tags</h3><p><strong>Marko</strong></p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">my-hello</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"Frank"</span>/&gt;</span>
</code></pre>
<pre><code class="lang-javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">(data, out)</span> </span>{
    out.write(<span class="hljs-string">'Hello '</span> + data.name + <span class="hljs-string">'!'</span>);
}
</code></pre>
<hr>

<p><strong>Dust:</strong></p>
<pre><code class="lang-html">{@my-hello name=&quot;Frank&quot; /}
</code></pre>
<pre><code class="lang-javascript">dust.helpers.hello = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helperTag</span><span class="hljs-params">(chunk, context, bodies, params)</span> </span>{
    <span class="hljs-keyword">return</span> chunk.write(<span class="hljs-string">'Hello '</span> + params.name + <span class="hljs-string">'!'</span>);
}
</code></pre>
<h2 id="detailed-comparisons"><a name="detailed-comparisons" class="anchor" href="#detailed-comparisons"><span class="header-link"></span></a>Detailed Comparisons</h2><h3 id="overview"><a name="overview" class="anchor" href="#overview"><span class="header-link"></span></a>Overview</h3><p>In the following sections we will take a deep dive into various aspects of Marko and Dust. Specifically, we will evaluate each templating language based on the following criteria:</p>
<ul>
<li><strong>Readability:</strong> How easy is it to discern the HTML structure of a template and understand what it will produce?</li>
<li><strong>Ramp-up Time:</strong> What does the learning curve look like?</li>
<li><strong>JavaScript API Usability:</strong> How easy is it to use the JavaScript API to compile and render templates and also extend the language?</li>
<li><strong>DRY (Don&#39;t Repeat Yourself):</strong> How DRY is the templating technology? Is there support for code reuse and partials?</li>
<li><strong>Asynchronous and Streaming Support:</strong> How well is asynchronous rendering and streaming supported?</li>
<li><strong>Interoperability:</strong> How easy is the templating language to integrate into an existing stack?</li>
<li><strong>Extensibility:</strong> How easy can the language be extended at runtime and compile-time? What are the restrictions?</li>
<li><strong>Rendering Performance:</strong> What is the CPU and memory overhead?</li>
<li><strong>Page Weight:</strong> What is the weight of the runtime and the compiled templates?</li>
<li><strong>Ease of Debugging:</strong> Is it possible to step through the code while it&#39;s running to track down errors?</li>
<li><strong>Security:</strong> How helpful is the templating language in preventing security holes such as XSS attacks?</li>
<li><strong>Validation:</strong> What validations can be done at compile-time to prevent errors at runtime?</li>
<li><strong>Editor Support:</strong> Is there an editor with auto-complete, syntax highlighting, error checking, etc.?</li>
<li><strong>Community:</strong> Is there an active community using this project? Can questions be answered via a search engine?</li>
<li><strong>Maturity:</strong> Is this a relatively stable project or still experimenting and churning?</li>
<li><strong>Documentation:</strong> How is the documentation?</li>
<li><strong>Future Relevancy:</strong> Is the templating language aligned with trends in the industry?</li>
</ul>
<h3 id="readability"><a name="readability" class="anchor" href="#readability"><span class="header-link"></span></a>Readability</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>No wrapping of HTML is required for conditional and repeated blocks</li>
            <li>HTML templates look like HTML</li>
            <li>Final HTML structure is immediately obvious</li>
        </ul>
    </div>
    <div class="col2 decent">
        <h1>Dust</h1>
        <ul>
            <li>Less logic due to restrictions</li>
            <li>Simpler code for checking empty arrays</li>
            <li>Template directives wrap HTML elements and make HTML structure harder to discern</li>
        </ul>
    </div>
</div>

<p>Readability is largely subjective, but let&#39;s compare a template from each language:</p>
<p><strong>Marko</strong></p>
<pre><code class="lang-html">Hello ${data.name}!

<span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">if</span>=<span class="hljs-value">"notEmpty(data.colors)"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"color"</span> <span class="hljs-attribute">for</span>=<span class="hljs-value">"color in data.colors"</span>&gt;</span>
        ${color}
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">else</span>&gt;</span>
    No colors!
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<p><strong>Dust:</strong></p>
<pre><code class="lang-html">Hello {name}!

{?colors}
<span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
    {#colors}
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"color"</span>&gt;</span>
        {.}
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    {/colors}
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
{:else}
<span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
    No colors!
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
{/colors}
</code></pre>
<p>A few things to note for the Marko template:</p>
<ul>
<li>Less lines of code</li>
<li>Less lines are &quot;touched&quot;</li>
<li>Only opening tags are modified for conditionals and looping</li>
</ul>
<h3 id="ramp-up-time"><a name="ramp-up-time" class="anchor" href="#ramp-up-time"><span class="header-link"></span></a>Ramp-up Time</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>Familiar HTML syntax is used as the input language</li>
            <li>JavaScript is used as the expression language</li>
        </ul>
    </div>
    <div class="col2 bad">
        <h1>Dust</h1>
        <ul>
            <li>Proprietary symbol-based syntax</li>
            <li>Only simple references are allowed</li>
            <li>Special loop variables have a fixed name (poor handling of nested loops)</li>
        </ul>
    </div>
</div>

<p>Comparing ramp-up time is difficult, but below is a summary of the <em>new concepts</em> that must be understood to truly master each templating language.</p>
<p><strong>Marko</strong></p>
<ul>
<li>Expressions<ul>
<li>Escaped: <code>$property.path</code>, <code>${javaScriptExpression}</code></li>
<li>Unescaped: <code>$!property.path</code>, <code>$!{javaScriptExpression}</code></li>
</ul>
</li>
<li>Simple conditionals: (<code>{?&lt;javascript-expression&gt;;&lt;true-template&gt;[;&lt;false-template&gt;]}</code>)</li>
<li>Custom tags and custom attributes<ul>
<li><code>marko-taglib.json</code></li>
<li><code>marko-tag.json</code></li>
</ul>
</li>
</ul>
<p>NOTE: The core taglib which includes <code>if</code>, <code>for</code>, etc., were not included since those are implemented using custom tags and custom attributes.</p>
<p><strong>Dust:</strong></p>
<ul>
<li>Partials: <code>{&gt;foo name=&quot;bar&quot;/}</code></li>
<li>Blocks: <code>{:blockname}</code>, <code>{:else}</code></li>
<li>Special blocks: <code>{+blockname}…{/blockname}</code></li>
<li>Filters: <code>{name|s|h|u}</code></li>
<li>Helper tags: <code>{@somehelper}…{/somehelper}</code></li>
<li>Block handlers: <code>{#somehandler}…{/somehandler}</code></li>
<li>Conditional blocks: <code>{?somekey}…{/somekey}</code></li>
<li>Negated conditionals: <code>{^somekey}…{/somekey}</code></li>
<li>Looped sections: <code>{#somearray}{/somearray}</code></li>
<li>Looping separator: <code>{@sep}, {/sep}</code></li>
<li>Loop variables: <code>$idx</code>, <code>$len</code></li>
<li>Comments: <code>{! … !}</code></li>
</ul>
<p>Obsolete or rarely used Dust syntax:</p>
<ul>
<li>Partial context: <code>{&gt;name:.context}</code></li>
<li>Recursion: <code>&gt;</code></li>
<li>Pragmas: <code>%pragma</code></li>
<li>New line: <code>{~n}</code></li>
<li>Escaping using pragmas: <code>{%esc:s}…{/esc}</code></li>
<li>Looping index: <code>{@idx}{.}{/idx}</code></li>
</ul>
<p>While Dust has a lot in common with Handlebars and Mustache, it is still a unique language. In comparison, Marko uses the HTML syntax to introduce templating directives (except in the case of dynamic text tokens).</p>
<p>The JavaScript API also impacts ramp-up time and that is described in the next section.</p>
<h3 id="javascript-api-usability"><a name="javascript-api-usability" class="anchor" href="#javascript-api-usability"><span class="header-link"></span></a>JavaScript API Usability</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>Simple and intuitive API</li>
            <li>Favors passing simple JavaScript objects</li>
            <li>JavaScript is used as the expression language</li>
            <li>Asynchronous rendering context is independent of Marko</li>
            <li>The API for Marko is simpler and more intuitive.</li>
        </ul>
    </div>
    <div class="col2 bad">
        <h1>Dust</h1>
        <ul>
            <li>More complicated API</li>
            <li>Some esoteric method names (e.g. &quot;tap&quot;, &quot;shiftBlocks&quot;, &quot;makeBase&quot;, etc.)</li>
            <li>Hierarchical data lookup adds complexity and can be error-prone</li>
        </ul>
    </div>
</div>

<p>Here&#39;s a comparison of both public APIs:</p>
<p><strong>Marko</strong></p>
<ul>
<li><code>require(&#39;marko&#39;).load(path) : Template</code></li>
<li><code>require(&#39;marko&#39;).unload(path)</code></li>
<li><code>require(&#39;marko&#39;).createWriter(stream) :</code><a href="https://github.com/raptorjs/async-writer">AsyncWriter</a></li>
<li><code>require(&#39;marko/compiler&#39;).compile(src, path, options)</code></li>
<li><code>require(&#39;marko/compiler&#39;).compileFile(path, options, callback)</code></li>
<li><code>Template</code><ul>
<li><code>renderSync(data) : String</code></li>
<li><code>render(data, callback)</code></li>
<li><code>render(data, stream) :</code><a href="https://github.com/raptorjs/async-writer">AsyncWriter</a></li>
<li><code>stream(data) : Stream</code></li>
</ul>
</li>
<li><a href="https://github.com/raptorjs/async-writer">AsyncWriter</a><ul>
<li><code>this.write(str)</code></li>
<li><code>this.beginAsync(timeout)</code></li>
<li><code>this.end(timeout)</code></li>
<li><code>this.on(event, callback)</code></li>
<li><code>this.once(event, callback)</code></li>
<li><code>this.emit(event, …args)</code></li>
<li><code>this.global = {}</code></li>
</ul>
</li>
</ul>
<p><strong>Dust:</strong></p>
<ul>
<li><code>require(&#39;dustjs-linkedin&#39;).helpers = {}</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).cache = {}</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).register(name, tmpl)</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).render(name, context, callback)</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).stream(name, context)</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).renderSource(name, context, callback)</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).compileFn(source, name)</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).load(name, chunk, context)</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).loadSource(source, path)</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).makeBase(global)</code></li>
<li><code>Context</code><ul>
<li><code>wrap(context, name)</code></li>
<li><code>this.get(key)</code></li>
<li><code>this.getPath(cur, down)</code></li>
<li><code>this.push(head, idx, len)</code></li>
<li><code>this.rebase(head)</code></li>
<li><code>this.current()</code></li>
<li><code>this.getBlock(key, chk, ctx)</code></li>
<li><code>this.shiftBlocks(locals)</code></li>
</ul>
</li>
<li><code>Chunk</code><ul>
<li><code>this.write(data)</code></li>
<li><code>this.end(data)</code></li>
<li><code>this.map(callback)</code></li>
<li><code>this.tap(tap)</code></li>
<li><code>this.untap()</code></li>
<li><code>this.render(body, context)</code></li>
<li><code>this.reference(elem, context, auto, filters)</code></li>
<li><code>this.section(elem, context, bodies, params)</code></li>
<li><code>this.exists(elem, context, bodies)</code></li>
<li><code>this.notexists(elem, context, bodies)</code></li>
<li><code>this.block(elem, context, bodies)</code></li>
<li><code>this.partial(elem, context, params)</code></li>
<li><code>this.helper(name, context, bodies, params)</code></li>
<li><code>this.capture(body, context, callback)</code></li>
<li><code>this.setError(err)</code></li>
</ul>
</li>
</ul>
<h3 id="dry"><a name="dry" class="anchor" href="#dry"><span class="header-link"></span></a>DRY</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>Custom HTML tags</li>
            <li>Includes/partials</li>
            <li>Template inheritance</li>
            <li>Macros (inline parameterized partials)</li>
        </ul>
    </div>
    <div class="col2 decent">
        <h1>Dust</h1>
        <ul>
            <li>Custom helper tags</li>
            <li>Includes/partials</li>
            <li>Template inheritance</li>
            <li>Inline partials</li>
        </ul>
    </div>
</div>

<p>Where Dust falls short in this category is that it requires you to repeat expressions used for sections and blocks. For example:</p>
<p><strong>Marko</strong></p>
<pre><code class="lang-html">
<span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">if</span>=<span class="hljs-value">"notEmpty(person.friends)"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"friend"</span> <span class="hljs-attribute">for</span>=<span class="hljs-value">"friend in person.friends"</span>&gt;</span>
        ${friend}
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<p>In the above Marko template, the <code>person.friends</code> expression is only repeated twice.</p>
<p><strong>Dust:</strong></p>
<pre><code class="lang-html">{?person.friends}
<span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
    {#person.friends}
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"friend"</span>&gt;</span>{.}<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    {/person.friends}
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
{/person.friends}
</code></pre>
<p>In the above Dust template, the <code>person.friends</code> expression is repeated for a total of four times.</p>
<h3 id="asynchronous-and-streaming-support"><a name="asynchronous-and-streaming-support" class="anchor" href="#asynchronous-and-streaming-support"><span class="header-link"></span></a>Asynchronous and Streaming Support</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>Simple API</li>
            <li>Uses native Node.js streams</li>
            <li>Streams can be piped to an asynchronous render context</li>
            <li>Supports timeouts for asynchronous writers</li>
        </ul>
    </div>
    <div class="col2 decent">
        <h1>Dust</h1>
        <ul>
            <li>Asynchronous chunk created by &quot;chunk.map&quot; must be returned</li>
            <li>Does not use native Node.js streams</li>
            <li>Streams cannot be piped to chunks</li>
            <li>Asynchronous chunks do not support timeouts</li>
        </ul>
    </div>
</div>

<p>Examples of using the asynchronous rendering API for each templating engine is shown below:</p>
<p><strong>Marko</strong></p>
<pre><code class="lang-javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">(data, out)</span> </span>{
    <span class="hljs-keyword">var</span> asyncOut = out.beginAsync();
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        asyncOut.end(<span class="hljs-string">'Hello '</span> + data.name + <span class="hljs-string">'!'</span>);
    }, <span class="hljs-number">1000</span>);
}
</code></pre>
<p><strong>Dust:</strong></p>
<pre><code class="lang-javascript">dust.helpers.hello = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tagHandler</span><span class="hljs-params">(chunk, context, bodies, params)</span> </span>{
    <span class="hljs-keyword">return</span> chunk.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(asyncChunk)</span> </span>{
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
            chunk.end(<span class="hljs-string">'Hello '</span> + params.name + <span class="hljs-string">'!'</span>);
        }, <span class="hljs-number">1000</span>);
    })
};
</code></pre>
<p>Marko has the advantage that the <a href="https://github.com/raptorjs/async-writer">async-writer</a> module used to support asynchronous rendering to a stream is a public module independent of Marko.</p>
<h3 id="interoperability-1"><a name="interoperability-1" class="anchor" href="#interoperability-1"><span class="header-link"></span></a>Interoperability</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>Works on client and server</li>
            <li>Dependent on npm and a Node.js-compatible module loader</li>
            <li>
                Marko works seamlessly with the Node.js ecosystem
                <ul>
                    <li>Marko template files compile to CommonJS modules (no named templates or global template registry)</li>
                    <li>Any CommonJS module can be required and used inside a Marko template</li>
                    <li>Custom taglibs installed via <a href="https://www.npmjs.org/">npm</a> are automatically discovered</li>
                </ul>
            </li>
            <li>Custom tag renderers are coded using a simple API that is independent of Marko</li>
            <li>
                Runtime and compiled templates compatible with
                <a href="https://github.com/substack/node-browserify">Browserify</a> and the
                <a href="https://github.com/raptorjs/optimizer">RaptorJS Optimizer</a>
                for client-side support
            </li>
        </ul>
    </div>
    <div class="col2 decent">
        <h1>Dust</h1>
        <ul>
            <li>Works on client and server</li>
            <li>Dependency free</li>
            <li>Easy to use in any JavaScript environment</li>
        </ul>
    </div>
</div>

<p>Neither Marko nor Dust will conflict with your existing code.</p>
<p>Adopting CommonJS modules as the output for compiled Marko Template files has some advantages. For example, the following code illustrates how a vanilla CommonJS module can be imported into a template for use as a helper:</p>
<pre><code class="lang-javascript">&lt;<span class="hljs-built_in">require</span> <span class="hljs-built_in">module</span>=<span class="hljs-string">"./my-util"</span> <span class="hljs-keyword">var</span>=<span class="hljs-string">"util"</span> /&gt;
Hello ${util.reverse(name)}!
</code></pre>
<h3 id="extensibility-1"><a name="extensibility-1" class="anchor" href="#extensibility-1"><span class="header-link"></span></a>Extensibility</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>Custom HTML tags</li>
            <li>Custom HTML attributes</li>
            <li>Custom compile-time transformers (psuedo DOM API)</li>
            <li>Custom compile-time code generators for AST nodes</li>
            <li>Custom taglibs that can be installed using <a href="https://www.npmjs.org/">npm</a></li>
            <li>CommonJS modules can be imported as helpers inside templates</li>
            <li>Custom taglibs are automatically discovered based on template file path</li>
            <li>Simple API to build custom tag renderers</li>
        </ul>
    </div>
    <div class="col2 decent">
        <h1>Dust</h1>
        <ul>
            <li>Custom helper tags</li>
            <li>Custom compile-time AST transforms (not well-documented)</li>
            <li>Code required to register helper tags</li>
        </ul>
    </div>
</div>

<p>Let&#39;s take a look at a sample custom tag for Marko and a sample custom helper for Dust:</p>
<p><strong>Marko</strong></p>
<pre><code class="lang-javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">(data, out)</span> </span>{
    out.write(<span class="hljs-string">'Hello '</span> + data.name + <span class="hljs-string">'!'</span>);
}
</code></pre>
<p><strong>Dust:</strong></p>
<pre><code class="lang-javascript">dust.helpers.hello = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(chunk, context, bodies, params)</span> </span>{
    <span class="hljs-keyword">return</span> chunk.write(<span class="hljs-string">'Hello '</span> + params.name + <span class="hljs-string">'!'</span>);
};
</code></pre>
<p>Let&#39;s take a look at more complicated example borrowed from the <a href="https://github.com/linkedin/dustjs/wiki/Dust-Tutorial#writing-a-dust-helper">Dust.js tutorial</a>. With this example our goal is to achieve the following:</p>
<p><em>Marko</em></p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">util-substr</span> <span class="hljs-attribute">str</span>=<span class="hljs-value">"xxx"</span> <span class="hljs-attribute">begin</span>=<span class="hljs-value">"x"</span> <span class="hljs-attribute">end</span>=<span class="hljs-value">"y"</span> <span class="hljs-attribute">len</span>=<span class="hljs-value">"z"</span> /&gt;</span>
</code></pre>
<p><em>Dust:</em></p>
<pre><code class="lang-html">{@substr str=&quot;xxx&quot; begin=&quot;x&quot; end=&quot;y&quot; len=&quot;z&quot; /}
</code></pre>
<p>NOTE: This example is for demonstration purposes only. The <code>&lt;util-substr&gt;</code> tag would be useless for Marko since you can use JavaScript expressions in your template. For example:</p>
<pre><code class="lang-html">${str.slice(0, -2)}
</code></pre>
<p><em>Marko</em></p>
<pre><code class="lang-javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">(data, out)</span> </span>{
    <span class="hljs-keyword">var</span> str = data.str;
    <span class="hljs-keyword">var</span> begin = data.begin || <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> end = data.end;
    <span class="hljs-keyword">var</span> len = data.len;

    <span class="hljs-keyword">if</span> (len != <span class="hljs-literal">null</span>) {
        str = str.substr(begin, len);
    } <span class="hljs-keyword">else</span> {
        str = str.slice(begin, end);
    }

    out.write(str);
}
</code></pre>
<p>Below is the implementation from the Dust documentation (cleaned up):</p>
<p><em>Dust:</em></p>
<pre><code class="lang-javascript">dust.helpers.substr = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(chunk, ctx, bodies, params)</span> </span>{
    <span class="hljs-comment">// Get the values of all the parameters. The tap function takes care of resolving</span>
    <span class="hljs-comment">// any variable references used in parameters (e.g. param="{name}")</span>
    <span class="hljs-keyword">var</span> str = dust.helpers.tap(params.str, chunk, ctx);
    <span class="hljs-keyword">var</span> begin = dust.helpers.tap(params.begin, chunk, ctx) || <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> end = dust.helpers.tap(params.end, chunk, ctx);
    <span class="hljs-keyword">var</span> len = dust.helpers.tap(params.len, chunk, ctx);

    <span class="hljs-keyword">if</span> (len != <span class="hljs-literal">null</span>) {
        str = str.substr(begin, len);
    } <span class="hljs-keyword">else</span> {
        str = str.slice(begin, end);
    }

    <span class="hljs-keyword">return</span> chunk.write(str);
}
</code></pre>
<p>Because Marko favors simple JavaScript objects, the tag implementation is much simpler for Marko.</p>
<p>Marko was designed to be extended via an API that is not tied to Marko. This allows custom tag renderers to be usable outside the context of template rendering (such as being called directly from JavaScript code).</p>
<p>With Marko, the <code>data</code> argument is just a standard JavaScript object with no tie-ins to Marko. The <code>out</code> argument is an <a href="https://github.com/raptorjs/async-writer">AsyncWriter</a> object that wraps a standard Node.js stream and it is independent of Marko.</p>
<p>In comparison, the <code>chunk</code> argument is a Dust <code>Chunk</code> object. The <code>context</code> is a Dust <code>Context</code> object and the <code>bodies</code> object is very specific to <code>Dust</code> as well. When you are building helpers for Dust, those helpers will only work with Dust (unless an abstraction is utilized).</p>
<h3 id="rendering-performance"><a name="rendering-performance" class="anchor" href="#rendering-performance"><span class="header-link"></span></a>Rendering Performance</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>Fastest streaming templating engine</li>
            <li>Less method calls during rendering</li>
            <li>Native JavaScript expressions, if conditions and loops</li>
        </ul>
    </div>
    <div class="col2 decent">
        <h1>Dust</h1>
        <ul>
            <li>Slower</li>
            <li>Less optimized compiled JavaScript</li>
            <li>Hierarchical context lookups can be slower</li>
        </ul>
    </div>
</div>

<p>Marko has significantly better rendering performance when compared to Dust. For benchmarks, please see <a href="https://github.com/raptorjs/templating-benchmarks">Templating Benchmarks</a>.</p>
<p>The memory utilization has not been compared, but I suspect that the memory usage is very similar.</p>
<h3 id="page-weight"><a name="page-weight" class="anchor" href="#page-weight"><span class="header-link"></span></a>Page Weight</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>Smaller runtime</li>
            <li>Smallest compiled templates</li>
        </ul>
    </div>
    <div class="col2 decent">
        <h1>Dust</h1>
        <ul>
            <li>Larger runtime</li>
            <li>Larger compiled templates</li>
        </ul>
    </div>
</div>

<p>Marko produces smaller compiled templates and has a smaller runtime. For benchmarks, please see <a href="https://github.com/raptorjs/templating-benchmarks">Templating Benchmarks</a>.</p>
<h3 id="ease-of-debugging"><a name="ease-of-debugging" class="anchor" href="#ease-of-debugging"><span class="header-link"></span></a>Ease of Debugging</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>Very clean and readable compiled JavaScript code</li>
            <li>Stack traces accurate on the server (compiled source loaded from disk using <code>require</code>)</li>
        </ul>
    </div>
    <div class="col2 bad">
        <h1>Dust</h1>
        <ul>
            <li>Less readable JavaScript output</li>
            <li>Compiled JavaScript code is all on one line</li>
        </ul>
    </div>
</div>

<p>Example compiled output for Marko:</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span><span class="hljs-params">(__helpers)</span> </span>{
  <span class="hljs-keyword">var</span> empty = __helpers.e,
      notEmpty = __helpers.ne,
      escapeXml = __helpers.x,
      forEach = __helpers.f;

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">(data, out)</span> </span>{
    out.w(<span class="hljs-string">'Hello '</span> +
      escapeXml(data.name) +
      <span class="hljs-string">'! '</span>);

    <span class="hljs-keyword">if</span> (notEmpty(data.colors)) {
      out.w(<span class="hljs-string">'&lt;ul&gt;'</span>);

      forEach(data.colors, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(color)</span> </span>{
        out.w(<span class="hljs-string">'&lt;li class="color"&gt;'</span> +
          escapeXml(color) +
          <span class="hljs-string">'&lt;/li&gt;'</span>);
      });

      out.w(<span class="hljs-string">'&lt;/ul&gt;'</span>);
    }
    <span class="hljs-keyword">else</span> {
      out.w(<span class="hljs-string">'&lt;div&gt;No colors!&lt;/div&gt;'</span>);
    }
  };
}
</code></pre>
<p>Example compiled output for Dust:</p>
<pre><code class="lang-javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{dust.register(<span class="hljs-string">"simple-1"</span>,body_0);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">body_0</span><span class="hljs-params">(chk,ctx)</span></span>{<span class="hljs-keyword">return</span> chk.write(<span class="hljs-string">"Hello "</span>).reference(ctx.get([<span class="hljs-string">"name"</span>], <span class="hljs-literal">false</span>),ctx,<span class="hljs-string">"h"</span>).write(<span class="hljs-string">"!"</span>).exists(ctx.get([<span class="hljs-string">"colors"</span>], <span class="hljs-literal">false</span>),ctx,{<span class="hljs-string">"block"</span>:body_1},<span class="hljs-literal">null</span>).notexists(ctx.get([<span class="hljs-string">"colors"</span>], <span class="hljs-literal">false</span>),ctx,{<span class="hljs-string">"block"</span>:body_3},<span class="hljs-literal">null</span>);}<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">body_1</span><span class="hljs-params">(chk,ctx)</span></span>{<span class="hljs-keyword">return</span> chk.write(<span class="hljs-string">" &lt;ul&gt;"</span>).section(ctx.get([<span class="hljs-string">"colors"</span>], <span class="hljs-literal">false</span>),ctx,{<span class="hljs-string">"block"</span>:body_2},<span class="hljs-literal">null</span>).write(<span class="hljs-string">"&lt;/ul&gt;"</span>);}<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">body_2</span><span class="hljs-params">(chk,ctx)</span></span>{<span class="hljs-keyword">return</span> chk.write(<span class="hljs-string">"&lt;li class=\"color\"&gt;"</span>).reference(ctx.getPath(<span class="hljs-literal">true</span>, []),ctx,<span class="hljs-string">"h"</span>).write(<span class="hljs-string">"&lt;/li&gt;"</span>);}<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">body_3</span><span class="hljs-params">(chk,ctx)</span></span>{<span class="hljs-keyword">return</span> chk.write(<span class="hljs-string">"&lt;div&gt;No colors!&lt;/div&gt;"</span>);}<span class="hljs-keyword">return</span> body_0;})();
</code></pre>
<h3 id="security"><a name="security" class="anchor" href="#security"><span class="header-link"></span></a>Security</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>Automatic HTML escaping of dynamic text (enabled by default)</li>
            <li>Allows arbitrary JavaScript code to be embedded in a template</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Dust</h1>
        <ul>
            <li>Automatic HTML escaping of dynamic text (enabled by default)</li>
            <li>Does not allow arbitrary JavaScript code to be embedded in a template</li>
            <li>Templates are guaranteed to be safe</li>
        </ul>
    </div>
</div>

<p>Marko does allow arbitrary JavaScript code to be used inside templates (all expressions in Marko templates are JavaScript). For this reason, it would not be appropriate to render untrusted Marko templates provided by a third-party (at least without sandboxing at a higher level). In comparison, expressions in Dust are interpreted at runtime and this approach does not allow arbitrary JavaScript code to be embedded in a template.</p>
<h3 id="validation"><a name="validation" class="anchor" href="#validation"><span class="header-link"></span></a>Validation</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>Attributes passed to custom tags are validated at compile-time</li>
            <li>Better type handling</li>
            <li>Custom code can easily be used to validate template structure at compile-time</li>
            <li>HTML parser can easily be used to analyze templates</li>
        </ul>
    </div>
    <div class="col2 bad">
        <h1>Dust</h1>
        <ul>
            <li>Only syntax is checked at compile-time</li>
            <li>Parameters passed to helper tags are not validated at compile-time</li>
            <li>Silently discards helper tags that it does not recognize</li>
        </ul>
    </div>
</div>

<p>As an example, the following code declares a simple custom tag for Marko, along with allowed attributes:</p>
<pre><code class="lang-javascript">{
    <span class="hljs-string">"tags"</span>: {
        <span class="hljs-string">"my-hello"</span>: {
            <span class="hljs-string">"renderer"</span>: <span class="hljs-string">"./renderer"</span>,
            <span class="hljs-string">"attributes"</span>: {
                <span class="hljs-string">"name"</span>: <span class="hljs-string">"string"</span>,
                <span class="hljs-string">"age"</span>: <span class="hljs-string">"integer"</span>
            }
        }
    }
}
</code></pre>
<p>The following template will successfully compile:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">my-hello</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"Frank"</span> <span class="hljs-attribute">age</span>=<span class="hljs-value">"20"</span>/&gt;</span>
</code></pre>
<p>However, the following template will result in an error during compilation:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">my-hello</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"Frank"</span> <span class="hljs-attribute">gender</span>=<span class="hljs-value">"male"</span>/&gt;</span>
</code></pre>
<p>Error message:</p>
<pre><code><span class="hljs-type">Error</span>: <span class="hljs-type">Errors</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">template</span>:

<span class="hljs-number">1</span>) [test-project/custom-tag.marko:<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] <span class="hljs-type">The</span> tag <span class="hljs-string">"my-hello"</span> <span class="hljs-keyword">in</span> taglib <span class="hljs-string">"test-project/marko-taglib.json"</span> does <span class="hljs-keyword">not</span> support attribute <span class="hljs-string">"gender"</span> (&lt;test-hello&gt;marko
</code></pre><p><em>NOTE: With Marko, declaring allowed attributes is an optional feature. As a custom tag developer, you can choose to allow all attributes by omitting the <code>attributes</code> property or by using the special <code>&quot;*&quot;: &quot;string&quot;</code> attribute definition.</em></p>
<h3 id="editor-support"><a name="editor-support" class="anchor" href="#editor-support"><span class="header-link"></span></a>Editor Support</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>Custom language grammar for Atom: <a href="https://atom.io/packages/language-marko">language-marko</a></li>
            <li>Compatible with any HTML editor</li>
            <li>Tag completion, HTML validation and syntax highlighting for free</li>
            <li>Declarative custom tags and attributes enables plugin developers to provide better validation and auto-completion</li>
            <li>Custom taglibs are automatically discovered (no code required)</li>
            <li>Any HTML parser can be used to analyze a Marko template</li>
        </ul>
    </div>
    <div class="col2 bad">
        <h1>Dust</h1>
        <ul>
            <li>Editor support:
                <ul>
                    <li>Emacs using <a href="http://web-mode.org/">web-mode</a></li>
                </ul>
            </li>
            <li>Code required to register custom helper tags</li>
            <li>No schema is attached to custom helper tags</li>
            <li>Proprietary and evolving AST</li>
        </ul>
    </div>
</div>

<h3 id="community-1"><a name="community-1" class="anchor" href="#community-1"><span class="header-link"></span></a>Community</h3><div class="compare">
    <div class="col1 bad">
        <h1>Marko</h1>
        <ul>
            <li>Emerging templating language</li>
            <li>Used by only a few companies (including eBay)</li>
            <li>Not heavily promoted</li>
            <li>Questions will be answered in Google Groups <a href="https://groups.google.com/forum/#!forum/raptorjs">discussion forum</a></li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Dust</h1>
        <ul>
            <li>Fairly strong community</li>
            <li>LinkedIn has helped promote Dust</li>
            <li>Active developers on <a href="http://stackoverflow.com/tags/dust.js/">StackOverflow</a></li>
        </ul>
    </div>
</div>

<h3 id="maturity"><a name="maturity" class="anchor" href="#maturity"><span class="header-link"></span></a>Maturity</h3><div class="compare">
    <div class="col1 bad">
        <h1>Marko</h1>
        <ul>
            <li>Relatively mature</li>
            <li>Used in heavily trafficked websites</li>
            <li>
                Recent and significant improvements:
                <ul>
                    <li>Switched from XML to HTML</li>
                    <li>Dropped XML namespaces</li>
                    <li>Better Node.js compatibility</li>
                    <li>Switched to CommonJS modules for compiled output</li>
                    <li>Faster and lighter</li>
                </ul>
            </li>
            <li>Lots of tests</li>
            <li>Still being improved</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Dust</h1>
        <ul>
            <li>Relatively mature</li>
            <li>Used in heavily trafficked websites</li>
            <li>Still being improved</li>
            <li>Lots of tests</li>
        </ul>
    </div>
</div>


<h3 id="documentation"><a name="documentation" class="anchor" href="#documentation"><span class="header-link"></span></a>Documentation</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>Fairly complete <a href="https://github.com/raptorjs/marko">documentation</a></li>
            <li>Documentation is in a <a href="https://github.com/raptorjs/marko/blob/master/README.md">README.md</a> file</li>
            <li>Legacy online testbed needs to be migrated to new version</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Dust</h1>
        <ul>
            <li>Fairly complete <a href="https://github.com/linkedin/dustjs/wiki/Dust-Tutorial">documentation</a></li>
            <li>Node.js and JavaScript API documentation lacking</li>
            <li>Poor examples in <a href="http://linkedin.github.io/dustjs/test/test.html">online testbed</a></li>
            <li>Documentation is on Wiki and not README file (no Pull Requests)</li>
        </ul>
    </div>
</div>

<p>Documentation for both Marko and Dust could use some improvement in a few areas, but overall the documentation is pretty good for both.</p>
<h3 id="future-relevancy"><a name="future-relevancy" class="anchor" href="#future-relevancy"><span class="header-link"></span></a>Future Relevancy</h3><div class="compare">
    <div class="col1 good">
        <h1>Marko</h1>
        <ul>
            <li>Web Components and custom tags are becoming more popular</li>
            <li>Marko custom tags can be swapped out with Web Component custom tags</li>
            <li>Marko custom tag renderers can be used to render a shadow DOM</li>
            <li>Very easy to extend at compile-time and runtime</li>
            <li>Custom tags are not tied to Marko</li>
        </ul>
    </div>
    <div class="col2 decent">
        <h1>Dust</h1>
        <ul>
            <li>Custom helper tags are very much tied to Dust</li>
            <li>Does not embrace custom HTML tags</li>
        </ul>
    </div>
</div>

<p>Custom tags are an exciting trend that allow authors to define their own HTML tags that encapsulate view and behavior. The emerging Web Components standard and Marko both support custom tags. In addition, the popular AngularJS framework also supports custom tags (called directives). The difference between a Marko custom tag and a Web Components custom tag is that a Marko custom tag is expanded to HTML when rendered on either the server or the client and a Web Components custom tag is expanded to a shadow DOM at time of insertion into the DOM. Custom elements are a very natural fit for web development and that appears to be an industry trend. In addition, it is possible to use the renderer for a Marko custom tag to produce the shadow DOM for a Web Components custom tag.</p>
<p>Because Marko also adopts custom tags, Marko Template custom tags can be seamlessly swapped out with Web Component custom tags.</p>
<p>Another thing to consider is that because the Marko compiler recognizes the HTML structure of a template it is feasible to produce a DOM (or virtual DOM) when rendering a Marko template. This, of course, would require a different version of the compiler to be used, but the language or templates would not need to change at all.</p>
<p>Lastly, Marko is very extensible at compile-time and render time. This allows almost any feature to be added to the language with no restrictions. For example, while Marko doesn&#39;t support data binding out-of-the-box, it is feasible to introduce a custom taglib to support data binding. For example:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">data-bind-text</span>=<span class="hljs-value">"someProperty"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">data-bind-for</span>=<span class="hljs-value">"color in colors"</span>&gt;</span>$color<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<h2 id="summary"><a name="summary" class="anchor" href="#summary"><span class="header-link"></span></a>Summary</h2><p>If you made it this far you are either skimming to get final thoughts or you really want to make a good decision when deciding to invest in a templating language (if not the former, thank you for reading!).</p>
<p>As the developer of Marko, my obvious choice for an HTML templating language is Marko. Below are what I believe are the top five advantages that Marko offers over Dust:</p>
<ol>
<li><strong>HTML Syntax:</strong> Utilizing the HTML syntax is a much more natural fit for producing HTML output.</li>
<li><strong>Simpler:</strong> Utilizing JavaScript as the expression language, a simpler API and favoring simple JavaScript objects enables better performance and makes Marko easier to learn.</li>
<li><strong>Performance:</strong> Marko has significantly better performance, produces smaller compiled templates and has a lighter runtime.</li>
<li><strong>Editor Support and Validation:</strong> The HTML syntax and declarative taglibs allow for better editor support and validation.</li>
<li><strong>Extensibility:</strong> Marko is easily extensible at runtime and compile-time, which allows for endless possibilities and ensures you will never be forced to settle for a sub-optimal solution.</li>
</ol>
<p>As with all newer technologies, I had the chance to look at the current landscape and find room for improvement. While templating languages might seem like a solved problem, I think you will find the innovation that is part of Marko refreshing. Moving from a text-based templating language, such as Dust, to Marko may require a shift in mindset, but I believe the gains in productivity will be rewarding.</p>
<p>Marko is being used at eBay and other companies and it is continuing to evolve. I encourage you to join the community and help make Marko the templating language of choice for more developers.</p>
<p> If you are interested in a broader view of JavaScript templating languages, please see the related <a href="/the-javascript-templating-landscape/">The JavaScript Templating Landscape</a> post.</p>
<p> Special thanks to the following folks for reviewing this post and providing valuable feedback:</p>
<ul>
<li>David Robbins - <a href="https://github.com/davidrobbins">Github</a> / <a href="http://wakandave.org/">Website</a></li>
<li>Phil Gates-Item - <a href="https://twitter.com/philidem">@philidem</a> / <a href="https://github.com/philidem/">Github</a></li>
<li>Ramesh Mahadevan - <a href="https://twitter.com/Ramesh1211">@Ramesh1211</a> / <a href="https://github.com/RameshRM/">Github</a></li>
<li>Santhosh Nageshwar Rao - <a href="https://twitter.com/santbob">@santbob</a> / <a href="https://github.com/santbob/">Github</a></li>
<li>Senthil Padmanabhan - <a href="https://twitter.com/senthil_hi">@senthil_hi</a> / <a href="http://www.senthilp.com/">Website</a> / <a href="https://github.com/senthilp">Github</a></li>
</ul>
</div><div class="post-footer"><div class="sharing"><a href="https://twitter.com/share" class="twitter-share-button" data-via="psteeleidem">Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></div><div class="post-nav"></div></div></article><section><h1>Comments</h1><div id="disqus_thread"></div><script type="text/javascript">
    var disqus_shortname = "psteeleidem";var disqus_identifier = "marko-versus-dust";var disqus_title = "Marko versus Dust";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></section></main><aside id="sidebar"><div id="logo"><a href="http://psteeleidem.com/"><img src="/static/logo-b7524d72.jpg" alt="Patrick Steele-Idem"></a></div><p class="bio"><p>Web Developer with a passion for JavaScript and Node.js.</p>
<p>Senior Platform Architect at eBay.</p>
</p><p class="links"><a href="https://github.com/patrick-steele-idem"><i class="fa fa-github fa-2x"></i></a> <a href="https://twitter.com/psteeleidem"><i class="fa fa-twitter fa-2x"></i></a> <a href="https://www.npmjs.org/~pnidem"><img src="/static/npm-logo-7e4eb9dd.png"></a></p><section><h1>Projects</h1><ul><li><a href="https://github.com/raptorjs/marko">Marko</a></li><li><a href="https://github.com/raptorjs/marko-widgets">Marko Widgets</a></li><li><a href="https://github.com/raptorjs/optimizer">RaptorJS Optimizer</a></li></ul></section><section><h1>Explore</h1><ul><li><a href="/category/dust/">Dust (2)</a></li><li><a href="/category/express/">Express (1)</a></li><li><a href="/category/javascript/">JavaScript (4)</a></li><li><a href="/category/marko/">Marko (4)</a></li><li><a href="/category/templating/">Templating (4)</a></li></ul></section></aside><footer id="footer"><section id="footer-message">&copy; 2014 Patrick Steele-Idem. All rights reserved. Powered by <a href="https://github.com/patrick-steele-idem/freeze" target="_blank">Freeze</a>.</section></footer></div><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-50307227-1', 'psteeleidem.com');
  ga('send', 'pageview');

</script></body></html>
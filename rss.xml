<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>Patrick Steele-Idem</title>
        <description>Web Development, JavaScript, Node.js and open source software.</description>
        <link>http://psteeleidem.com/</link>
        <lastBuildDate>Thu, 24 Apr 2014 22:55:08 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <copyright>All rights reserved 2014, Patrick Steele-Idem</copyright>
        <generator>Feed for Node.js</generator>
        <item>
            <title><![CDATA[Raptor Templates versus Dust]]></title>
            <link>/raptor-versus-dust/</link>
            <guid>/raptor-versus-dust/</guid>
            <pubDate>Thu, 24 Apr 2014 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>This guide aims to compare <a href="https://github.com/raptorjs3/raptor-templates">Raptor Templates</a> and <a href="https://github.com/linkedin/dustjs">Dust</a> to help guide developers deciding between the two. However, even if you are considering other templating languages, such as Handlebars or Mustache, this guide should still be helpful.</p>
<p>Why Raptor Templates and Dust? Dust represents a well-established text-based templating language and Raptor Templates represents a well-established HTML-based templating language. Raptor Templates was created as an alternative to Dust when Dust was first starting to be used at eBay.</p>
<p><em>Disclaimer: This guide is my opinion, and as the author of Raptor Templates it is very difficult for me to be unbiased. Also, I&#39;ve used Dust enough to be proficient in it, but I would not claim to be a Dust expert. If you feel that anything is misleading or wrong then please let me know and I will correct it. Also, my goal was to be as objective and as fair as possible, but some things are inherently subjective.</em></p>
<p><p class="toc"><strong>Table of Contents</strong><ul class="toc-level0"><li><a href="#overview">Overview</a></li><li><a href="#features">Features</a></li><li><a href="#readability">Readability</a></li><li><a href="#ramp-up-time">Ramp-up Time</a></li><li><a href="#javascript-api-usability">JavaScript API Usability</a></li><li><a href="#dry">DRY</a></li><li><a href="#asynchronous-and-streaming-support">Asynchronous and Streaming Support</a></li><li><a href="#interoperability">Interoperability</a></li><li><a href="#extensibility">Extensibility</a></li><li><a href="#rendering-performance">Rendering Performance</a></li><li><a href="#page-weight">Page Weight</a></li><li><a href="#ease-of-debugging">Ease of Debugging</a></li><li><a href="#security">Security</a></li><li><a href="#validation">Validation</a></li><li><a href="#editor-support">Editor Support</a></li><li><a href="#community">Community</a></li><li><a href="#maturity">Maturity</a></li><li><a href="#documentation">Documentation</a></li><li><a href="#future-relevancy">Future Relevancy</a></li><li><a href="#summary">Summary</a></li></ul></p></p>
<style type="text/css">
.compare {
    margin-top: 1.1em;
    margin-bottom: 1.1em;
    width: 100%;
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}

.compare h1 {
    margin-top: 0.1em;
    margin-bottom: 0.1em;
    font-size: 1.5em;
}

.compare:after {
    content: "";
    display: table;
    clear: both;
}

.compare div {
    padding: 0.5em;
    border: 1px solid #c0c0c0;
    float: left;
    width: 49%;
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}

.compare .col1 {
    margin-right: 1%;
}

.compare .col2 {
    margin-left: 1%;
}

.compare ul {
    margin-left: 1em;
}

.compare .good {
    background-color: #C9FF28;
}

.compare .decent {
    background-color: #FFE896;
}

.compare .bad {
    background-color: #FFAAAA;
}

/* Tiny Screens */
@media only screen and (max-width: 767px) { 
    .compare div {
        padding: 0.4em;
        border: 1px solid #c0c0c0;
        float: none;
        width: auto;
        -webkit-box-sizing: border-box;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
    }

    .compare .col1 {
        margin-right: 0;
        margin-bottom: 1em;
    }

    .compare .col2 {
        margin-left: 0;
    }
}
</style>

<h2 id="overview"><a name="overview" class="anchor" href="#overview"><span class="header-link"></span></a>Overview</h2><p>For this guide we will be comparing Dust and Raptor Templates based on the following criteria:</p>
<ul>
<li><strong>Readability:</strong> How easy is it to descern the HTML structure of a template and understand what it will produce?</li>
<li><strong>Ramp-up Time:</strong> What does the learning curve look like?</li>
<li><strong>JavaScript API Usability:</strong> How easy is it to use the JavaScript API compile and render templates and also extend the language?</li>
<li><strong>DRY (Don&#39;t Repeat Yourself):</strong> How DRY is the templating technology? Is there support for code reuse and partials?</li>
<li><strong>Asynchronous and Streaming Support:</strong> How well is asynchronous rendering and streaming supported?</li>
<li><strong>Interoperability:</strong> How easy is the templating language to integrate into an existing stack?</li>
<li><strong>Extensibility:</strong> How easy can the language be extended at runtime and compile time? What are the restrictions?</li>
<li><strong>Rendering Performance:</strong> What is the CPU and memory overhead?</li>
<li><strong>Page Weight:</strong> What is the weight of the runtime and the compiled templates?</li>
<li><strong>Ease of Debugging:</strong> Is it possible to step through the code while it&#39;s running to track down errors?</li>
<li><strong>Security:</strong> How helpful is the templating language in preventing security holes such as XSS attacks?</li>
<li><strong>Validation:</strong> What validations can be done at build time to prevent errors at runtime?</li>
<li><strong>Editor Support:</strong> Is there an editor with auto-complete, syntax highlighting, error checking, etc.?</li>
<li><strong>Community:</strong> Is there an active community using this project? Can questions be answered via a search engine?</li>
<li><strong>Maturity:</strong> Is this a relatively stable project or still experimenting and churning?</li>
<li><strong>Documentation:</strong> How is the documentation?</li>
<li><strong>Future Relevancy:</strong> Is the templating language aligned with trends in the industry?</li>
</ul>
<h2 id="features"><a name="features" class="anchor" href="#features"><span class="header-link"></span></a>Features</h2><p>Before we go into a comparison for each category, let&#39;s take a look at a high-level overview of the features of each templating language:</p>
<p><strong>Dust:</strong></p>
<ul>
<li>Text-based templating language</li>
<li>Streaming support</li>
<li>Asynchronous rendering support</li>
<li>Compatible with Node.js and the browser</li>
<li>Extensible via custom helper tags</li>
<li>Contributors from multiple companies, including LinkedIn and eBay</li>
<li>Design Philosophy (from original author):<ul>
<li><strong>Markup-like:</strong> A templating syntax should not encompass operations that are better left to a programming language. Templates should make it easy to format content for presentation while keeping application logic where it belongs: in the application.</li>
<li><strong>Asynchronous:</strong> Template helpers should be callable asynchronously and in parallel so that expensive operations (caching, deferred loading, filtering) can run as the template is being rendered.</li>
<li><strong>Streaming:</strong> Templates should allow (but not require) data to be flushed to the output in user-defined chunks.</li>
<li><strong>Browser and server compatible:</strong> Templates should render in both server and browser environments without hacks or extensive configuration.</li>
<li><strong>Storage agnostic:</strong> The templating engine should not impose a particular loading scheme. Developers should be free to load templates via the filesystem, a database or an army of carrier pigeons.</li>
<li><strong>Composable:</strong> Designers should be able to break presentation markup into manageable components and combine these components at runtime. It should not be necessary to statically link templates or manually assemble &#39;layouts&#39; inside application code.</li>
<li><strong>Format agnostic:</strong> While HTML generation and DOM manipulation are useful in specific instances, a general-purpose template system should not be tied to a particular output format.</li>
<li><strong>Precise:</strong> The parser should be accurate enough that designers rarely have to use escape sequences to achieve the desired result. Similarly, templates shouldn&#39;t mysteriously generate or eliminate whitespace.</li>
<li><strong>Safe(r):</strong> At the very least, the engine should be configurable such that it is reasonably safe to render untrusted templates in a server environment.</li>
<li><strong>Fast:</strong> Server-side templates cannot always be cached. Browser-side templates may be rendered on devices with limited system resources. A template engine should be fast enough to render in real time without bottlenecking its environment.</li>
</ul>
</li>
</ul>
<p><strong>Raptor Templates:</strong></p>
<ul>
<li>HTML-based templating language</li>
<li>Streaming support</li>
<li>Asynchronous rendering support</li>
<li>Compatible with Node.js and the browser</li>
<li>Extensible via the following:<ul>
<li>Custom tags</li>
<li>Custom attributes</li>
<li>Custom compilers and compile-time transformers</li>
<li>Custom taglibs can be installed via <a href="https://www.npmjs.org/">npm</a></li>
</ul>
</li>
<li><a href="https://github.com/raptorjs3/templating-benchmarks">High performance and small footprint</a></li>
<li>Contributors from multiple companies, including eBay</li>
<li>Design Philosophy<ul>
<li><strong>Readable:</strong> Templates should be as close to the output HTML as possible to keep templates readable. Cryptic syntax and symbols should be avoided.</li>
<li><strong>Simple:</strong> The number of new concepts should be minimized to reduce the learning curve and complexity.</li>
<li><strong>Extensible:</strong> The template engine should be easily extensible at both compile time and runtime.</li>
<li><strong>High Performance:</strong> Runtime and compiled output should be optimized for low CPU and memory usage and have a small footprint. All expressions should be native JavaScript to avoid runtime interpretation.</li>
<li><strong>Asynchronous and Streaming Output:</strong> It should be possible to render HTML out-of-order, but the output HTML should be streamed out in the correct order. This minimizes idle time and reduces the time to first byte.</li>
<li><strong>Intuitive:</strong> The templating engine should introduce as few surprises as possible.</li>
<li><strong>Browser and Server Compatibility:</strong> Templates should compile down to JavaScript that can be executed on both the server and the client.</li>
<li><strong>Debuggable:</strong> Compiled JavaScript should be debuggable and readable.</li>
<li><strong>Compile-Time Checks:</strong> Syntax, custom tags and custom attributes should be validated at compile-time.</li>
<li><strong>Tools Support:</strong> Tools should be enabled to offer auto-completion and validation for improved productivity and safety.</li>
<li><strong>Modular:</strong> Runtime and compiled templates should be based on CommonJS modules for improved dependency management. Template dependencies (such as custom tags) should resolved based on a template&#39;s file system path instead of relying on a shared registry.</li>
</ul>
</li>
</ul>
<h2 id="readability"><a name="readability" class="anchor" href="#readability"><span class="header-link"></span></a>Readability</h2><p>Readability is largely subjective, but let&#39;s compare a template from each language:</p>
<p><strong>Dust:</strong></p>
<pre><code class="lang-html">Hello {name}!

{?colors} 
<span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
    {#colors}
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"color"</span>&gt;</span>
        {.}
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    {/colors}
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
{:else}
<span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
    No colors!
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
{/colors}
</code></pre>
<p><strong>Raptor:</strong></p>
<pre><code class="lang-html">Hello ${data.<span class="hljs-property">name</span>}!

&lt;ul c-<span class="hljs-keyword">if</span>=<span class="hljs-string">"notEmpty(data.colors)"</span>&gt;
    &lt;li <span class="hljs-type">class</span>=<span class="hljs-string">"color"</span> c-<span class="hljs-keyword">for</span>=<span class="hljs-string">"color in data.colors"</span>&gt;
        ${color}
    &lt;/li&gt;
&lt;/ul&gt;
&lt;<span class="hljs-keyword">div</span> c-<span class="hljs-keyword">else</span>&gt;
    No colors!
&lt;/<span class="hljs-keyword">div</span>&gt;
</code></pre>
<div class="compare">
    <div class="col1 decent">
        <h1>Dust</h1>
        <ul>
            <li>Less logic due to restrictions</li>
            <li>Simpler code for checking empty arrays</li>
            <li>Template directives wrap HTML elements and make HTML structure harder to discern</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Less lines of code</li>
            <li>More DRY</li>
            <li>HTML templates looks like HTML</li>
            <li>Final HTML structure is immediately obvious</li>
        </ul>
    </div>
</div>

<p><strong>Winner: ✓ Raptor</strong></p>
<h2 id="ramp-up-time"><a name="ramp-up-time" class="anchor" href="#ramp-up-time"><span class="header-link"></span></a>Ramp-up Time</h2><p>Comparing ramp-up time is difficult, but below is a summary of the <em>new concepts</em> that must be understood to truly master each templating language.</p>
<p><strong>Dust:</strong></p>
<ul>
<li>Partials: <code>{&gt;foo name=&quot;bar&quot;/}</code></li>
<li>Blocks: <code>{:blockname}</code>, <code>{:else}</code></li>
<li>Special blocks: <code>{+blockname}…{/blockname}</code></li>
<li>Filters: <code>{name|s|h|u}</code></li>
<li>Helper tags: <code>{@helper}…{/helper}</code></li>
<li>Block handlers: <code>{#handler}…{/handler}</code></li>
<li>Conditional blocks: <code>{?somekey}…{/somekey}</code></li>
<li>Negated conditionals: <code>{^somekey}…{/somekey}</code></li>
<li>Looped sections: <code>{#somearray}{/somearray}</code></li>
<li>Looping separator: <code>{@sep}, {/sep}</code></li>
<li>Loop variables: <code>$idx</code>, <code>$len</code></li>
<li>Comments: <code>{! … !}</code></li>
</ul>
<p>Obsolete or rarely used Dust syntax:</p>
<ul>
<li>Partial context: <code>{&gt;name:.context}</code></li>
<li>Recursion: <code>&gt;</code></li>
<li>Pragmas: <code>%pragma</code></li>
<li>New line: <code>{~n}</code></li>
<li>Escaping using pragmas: <code>{%esc:s}…{/esc}</code></li>
<li>Looping index: <code>{@idx}{.}{/idx}</code></li>
</ul>
<p><strong>Raptor:</strong></p>
<ul>
<li>Expressions<ul>
<li>Escaped: <code>$&lt;property-path&gt;</code>, <code>${&lt;javascript-expression&gt;}</code></li>
<li>Unescaped: <code>$!&lt;property-path&gt;</code>, <code>$!{&lt;javascript-expression&gt;}</code></li>
</ul>
</li>
<li>Simple conditionals: (<code>{?&lt;javascript-expression&gt;;&lt;true-template&gt;[;&lt;false-template&gt;]}</code>)</li>
<li>Custom tags and custom attributes<ul>
<li><code>raptor-taglib.json</code></li>
<li><code>raptor-tag.json</code></li>
</ul>
</li>
</ul>
<p>NOTE: The core taglib which includes <code>c-if</code>, <code>c-for</code>, etc., were not included since those are implemented using custom tags and custom attributes.</p>
<div class="compare">
    <div class="col1 bad">
        <h1>Dust</h1>
        <ul>
            <li>Entirely new symbol-based syntax</li>
            <li>Only simple references are allowed</li>
            <li>Loop variables have a fixed name (poor handling of nested loops)</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Familiar HTML syntax is used as the input language</li>
            <li>JavaScript is used as the expression language</li>
        </ul>
    </div>
</div>

<p>While Dust has a lot in common with Handlebars and Dust, it is still a unique language. In comparison, Raptor Templates uses the HTML syntax to introduce templating directives (except in the case of dynamic text tokens).</p>
<p>The JavaScript API also impacts ramp-up time and that is described in the next section.</p>
<p><strong>Winner: ✓ Raptor</strong></p>
<h2 id="javascript-api-usability"><a name="javascript-api-usability" class="anchor" href="#javascript-api-usability"><span class="header-link"></span></a>JavaScript API Usability</h2><p>Here&#39;s a comparison of both public APIs:</p>
<p><strong>Dust:</strong></p>
<ul>
<li><code>require(&#39;dustjs-linkedin&#39;).helpers = {}</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).cache = {}</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).register(name, tmpl)</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).render(name, context, callback)</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).stream(name, context)</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).renderSource(name, context, callback)</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).compileFn(source, name)</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).load(name, chunk, context)</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).loadSource(source, path)</code></li>
<li><code>require(&#39;dustjs-linkedin&#39;).makeBase(global)</code></li>
<li><code>Context</code><ul>
<li><code>wrap(context, name)</code></li>
<li><code>this.get(key)</code></li>
<li><code>this.getPath(cur, down)</code></li>
<li><code>this.push(head, idx, len)</code></li>
<li><code>this.rebase(head)</code></li>
<li><code>this.current()</code></li>
<li><code>this.getBlock(key, chk, ctx)</code></li>
<li><code>this.shiftBlocks(locals)</code></li>
</ul>
</li>
<li><code>Chunk</code><ul>
<li><code>this.write(data)</code></li>
<li><code>this.end(data)</code></li>
<li><code>this.map(callback)</code></li>
<li><code>this.tap(tap)</code></li>
<li><code>this.untap()</code></li>
<li><code>this.render(body, context)</code></li>
<li><code>this.reference(elem, context, auto, filters)</code></li>
<li><code>this.section(elem, context, bodies, params)</code></li>
<li><code>this.exists(elem, context, bodies)</code></li>
<li><code>this.notexists(elem, context, bodies)</code></li>
<li><code>this.block(elem, context, bodies)</code></li>
<li><code>this.partial(elem, context, params)</code></li>
<li><code>this.helper(name, context, bodies, params)</code></li>
<li><code>this.capture(body, context, callback)</code></li>
<li><code>this.setError(err)</code></li>
</ul>
</li>
</ul>
<p><strong>Raptor:</strong></p>
<ul>
<li><code>require(&#39;raptor-templates&#39;).render(path, data, callback)</code></li>
<li><code>require(&#39;raptor-templates&#39;).render(path, data, context)</code></li>
<li><code>require(&#39;raptor-templates&#39;).stream(path, data)</code></li>
<li><code>require(&#39;raptor-templates&#39;).unload(path)</code></li>
<li><code>require(&#39;raptor-templates&#39;).createContext(stream)</code></li>
<li><code>require(&#39;raptor-templates/compiler&#39;).compile(src, path, options)</code></li>
<li><code>require(&#39;raptor-templates/compiler&#39;).compileFile(path, options, options)</code></li>
<li><code>Context</code><ul>
<li><code>this.write(str)</code></li>
<li><code>this.beginAsync(timeout)</code></li>
<li><code>this.end(timeout)</code></li>
<li><code>this.on(event, callback)</code></li>
<li><code>this.once(event, callback)</code></li>
<li><code>this.emit(event, ...args)</code></li>
<li><code>this.attributes = {}</code></li>
</ul>
</li>
</ul>
<div class="compare">
    <div class="col1 bad">
        <h1>Dust</h1>
        <ul>
            <li>Complicated API</li>
            <li>Esoteric method names (e.g. &quot;tap&quot;, &quot;shiftBlocks&quot;, &quot;makeBase&quot;, etc.)</li>
            <li>Hierarchical data lookup adds complexity and can be error-prone</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Favors passing around simple JavaScript objects</li>
            <li>JavaScript is used as the expression language</li>
            <li>Simple and intuitive API</li>
            <li>Asynchronous rendering context is independent of Raptor</li>
        </ul>
    </div>
</div>

<p>The API for Raptor Templates is simpler and more intuitive.</p>
<p><strong>Winner: ✓ Raptor</strong></p>
<h2 id="dry"><a name="dry" class="anchor" href="#dry"><span class="header-link"></span></a>DRY</h2><div class="compare">
    <div class="col1 decent">
        <h1>Dust</h1>
        <ul>
            <li>Custom helper tags</li>
            <li>Includes/partials</li>
            <li>References must be repeated</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Reusable custom tags</li>
            <li>Includes/partials</li>
            <li>Macros (inline parameterized partials)</li>
        </ul>
    </div>
</div>

<p>Where Dust falls short in this category is that it requires you to repeat expressions used for sections and blocks. For example:</p>
<p><strong>Dust:</strong></p>
<pre><code class="lang-html"><span class="hljs-list">{?person.friends}</span>
&lt;ul&gt;
    <span class="hljs-list">{#person.friends}</span>
    &lt;li class=<span class="hljs-string">"friend"</span>&gt;<span class="hljs-list">{.}</span>&lt;/li&gt;
    <span class="hljs-list">{/person.friends}</span>
&lt;/ul&gt;
<span class="hljs-list">{/person.friends}</span>
</code></pre>
<p>In the above Dust template, the <code>person.friends</code> expression is repeated for a total of four times. The same template in Raptor is shown below:</p>
<p><strong>Raptor:</strong></p>
<pre><code class="lang-html">
<span class="hljs-tag">&lt;<span class="hljs-title">ul</span> <span class="hljs-attribute">c-if</span>=<span class="hljs-value">"notEmpty(person.friends)"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"friend"</span> <span class="hljs-attribute">c-for</span>=<span class="hljs-value">"friend in person.friends"</span>&gt;</span>
        ${friend}
    <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
</code></pre>
<p>In the above Raptor template, the <code>person.friends</code> expression is only repeated twice.</p>
<p><strong>Winner: ✓ Raptor</strong></p>
<h2 id="asynchronous-and-streaming-support"><a name="asynchronous-and-streaming-support" class="anchor" href="#asynchronous-and-streaming-support"><span class="header-link"></span></a>Asynchronous and Streaming Support</h2><div class="compare">
    <div class="col1 decent">
        <h1>Dust</h1>
        <ul>
            <li>Asynchronous chunk created by &quot;chunk.map&quot; must be returned</li>
            <li>Does not use native Node.js streams</li>
            <li>Streams cannot be piped to chunks</li>
            <li>Asynchronous chunks do not support timeouts</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Simple API</li>
            <li>Uses native Node.js streams</li>
            <li>Streams can be piped to an asynchronous render context</li>
            <li>Supports timeouts for asynchronous contexts</li>
        </ul>
    </div>
</div>

<p>Examples of using the asynchronous rendering API for each templating engine is shown below:</p>
<p><strong>Dust:</strong></p>
<pre><code class="lang-javascript">dust.helpers.hello = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tagHandler</span><span class="hljs-params">(chunk, context, bodies, params)</span></span> {
    <span class="hljs-keyword">return</span> chunk.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(asyncChunk)</span></span> {
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> {
            chunk.<span class="hljs-keyword">end</span>(<span class="hljs-string">'Hello '</span> + input.name + <span class="hljs-string">'!'</span>);
        }, <span class="hljs-number">1000</span>);
    })
};
</code></pre>
<p><strong>Raptor:</strong></p>
<pre><code class="lang-javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">(input, context)</span></span> {
    var asyncContext = context.beginAsync();
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> {
        asyncContext.<span class="hljs-keyword">end</span>(<span class="hljs-string">'Hello '</span> + input.name + <span class="hljs-string">'!'</span>);
    }, <span class="hljs-number">1000</span>);
}
</code></pre>
<p>Raptor Templates has the advantage that the <a href="https://github.com/raptorjs3/raptor-render-context">asynchronous rendering context</a> module used to support asynchronous rendering to a stream is a public module independent of Raptor Templates.</p>
<p><strong>Winner: ✓ Raptor</strong></p>
<h2 id="interoperability"><a name="interoperability" class="anchor" href="#interoperability"><span class="header-link"></span></a>Interoperability</h2><div class="compare">
    <div class="col1 decent">
        <h1>Dust</h1>
        <ul>
            <li>Works on client and server</li>
            <li>Dependency free</li>
            <li>Easy to use in any JavaScript environment</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Works on client and server</li>
            <li>Dependent on npm and a Node.js-compatible module loader</li>
            <li>
                Raptor Templates works seamlessly with the Node.js ecosystem
                <ul>
                    <li>Raptor Template files compile to CommonJS modules (no global template registry)</li>
                    <li>Any CommonJS module can be required and used inside a Raptor template</li>
                    <li>Custom taglibs installed via <a href="https://www.npmjs.org/">npm</a> are automatically discovered</li>
                </ul>
            </li>
            <li>Custom tag renderers are coded using a simple API that is independent of Raptor Templates</li>
            <li>
                Runtime and compiled templates compatible with
                <a href="https://github.com/substack/node-browserify">Browserify</a> and the 
                <a href="https://github.com/raptorjs3/raptor-optimizer">RaptorJS Optimizer</a>
                for client-side support
            </li>
        </ul>
    </div>
</div>

<p>Neither Raptor Templates nor Dust will conflict with your existing code.</p>
<p>Adopting CommonJS modules as the output for compiled Raptor Template files has some advantages. For example, the following code illustrates how a vanilla CommonJS module can be imported into a template for use as a helper:</p>
<pre><code class="lang-javascript">&lt;c-<span class="hljs-built_in">require</span> <span class="hljs-built_in">module</span>=<span class="hljs-string">"./my-util"</span> <span class="hljs-reserved">var</span>=<span class="hljs-string">"util"</span> /&gt;
Hello ${util.reverse(name)}!
</code></pre>
<p><strong>Winner:</strong> </p>
<ul>
<li><strong>✓ Raptor</strong>, if using Node.js or a Node.js-compatible module loader such Browserify or the RaptorJS Optimizer</li>
<li><strong>✓ Dust</strong>, if <em>not</em> using a Node.js-compatible module loader</li>
</ul>
<h2 id="extensibility"><a name="extensibility" class="anchor" href="#extensibility"><span class="header-link"></span></a>Extensibility</h2><div class="compare">
    <div class="col1 decent">
        <h1>Dust</h1>
        <ul>
            <li>Helper tags</li>
            <li>Custom compile-time AST transforms (not well-documented)</li>
            <li>Code required to register helper tags</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Custom tags</li>
            <li>Custom attributes</li>
            <li>Custom compile-time transformers</li>
            <li>Custom compile-time code generators for AST nodes</li>
            <li>Custom taglibs that can be installed using <a href="https://www.npmjs.org/">npm</a></li>
            <li>CommonJS modules can be imported as helpers inside templates</li>
            <li>Custom taglibs are automatically discovered based on template file path</li>
            <li>Simple API to build custom tag renderers</li>
        </ul>
    </div>
</div>

<p>Let&#39;s take a look at a sample custom tag for Raptor and a sample custom helper for Dust:</p>
<p><strong>Dust:</strong></p>
<pre><code class="lang-javascript">dust.helpers.hello = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(chunk, context, bodies, params)</span> {</span>
    <span class="hljs-keyword">return</span> chunk.write(<span class="hljs-string">'Hello '</span> + params.name + <span class="hljs-string">'!'</span>);
};
</code></pre>
<p><strong>Raptor:</strong></p>
<pre><code class="lang-javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">(input, context)</span></span> {
    context.write(<span class="hljs-string">'Hello '</span> + input.name + <span class="hljs-string">'!'</span>);
}
</code></pre>
<p>Raptor Templates was designed to be extended via an API that is not tied to Raptor Templates. This allows custom tag renderers to be usable outside the context of a template rendering (such as being called directly from JavaScript code).</p>
<p>With Raptor, the <code>input</code> argument is just a standard JavaScript object with no tie-ins to Raptor Templates. The <code>context</code> argument is an <a href="https://github.com/raptorjs3/raptor-render-context">asynchronous render context</a> object that wraps a standard Node.js stream and it is independent of Raptor Templates.</p>
<p>In comparison, the <code>chunk</code> argument is a Dust <code>Chunk</code> object. The <code>context</code> is a Dust <code>Context</code> object and the <code>bodies</code> object is very specific to <code>Dust</code> as well. When you are building helpers for Dust, those helpers will only work with Dust (unless an abstraction is utilized).</p>
<p><strong>Winner: ✓ Raptor</strong></p>
<h2 id="rendering-performance"><a name="rendering-performance" class="anchor" href="#rendering-performance"><span class="header-link"></span></a>Rendering Performance</h2><div class="compare">
    <div class="col1 decent">
        <h1>Dust</h1>
        <ul>
            <li>Slower</li>
            <li>Less optimized compiled JavaScript</li>
            <li>Hierarchical context lookups can be slower</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Fastest streaming templating engine</li>
            <li>Less method calls during rendering</li>
            <li>Native JavaScript expressions, if conditions and loops</li>
        </ul>
    </div>
</div>

<p>Raptor has significantly better rendering performance when compared to Dust. For benchmarks, please see <a href="https://github.com/raptorjs3/templating-benchmarks">Templating Benchmarks</a>.</p>
<p>The memory utilization has not been compared, but I suspect that the memory usage is very similar.</p>
<p><strong>Winner: ✓ Raptor</strong></p>
<h2 id="page-weight"><a name="page-weight" class="anchor" href="#page-weight"><span class="header-link"></span></a>Page Weight</h2><div class="compare">
    <div class="col1 decent">
        <h1>Dust</h1>
        <ul>
            <li>Larger runtime</li>
            <li>Larger compiled templates</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Smaller runtime</li>
            <li>Smallest compiled templates</li>
        </ul>
    </div>
</div>

<p>Raptor produces smaller compiled templates and has a smaller runtime. For benchmarks, please see <a href="https://github.com/raptorjs3/templating-benchmarks">Templating Benchmarks</a>.</p>
<p><strong>Winner: ✓ Raptor</strong></p>
<h2 id="ease-of-debugging"><a name="ease-of-debugging" class="anchor" href="#ease-of-debugging"><span class="header-link"></span></a>Ease of Debugging</h2><div class="compare">
    <div class="col1 bad">
        <h1>Dust</h1>
        <ul>
            <li>Less readable JavaScript output</li>
            <li>Compiled JavaScript code is all on one line</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Very clean and readable compiled JavaScript code</li>
            <li>Stack traces accurate on the server (eval is not used to load templates)</li>
        </ul>
    </div>
</div>

<p>Example compiled output for Dust:</p>
<pre><code class="lang-javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>dust.register(<span class="hljs-string">"simple-1"</span>,body_0);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">body_0</span><span class="hljs-params">(chk,ctx)</span>{</span><span class="hljs-keyword">return</span> chk.write(<span class="hljs-string">"Hello "</span>).reference(ctx.<span class="hljs-keyword">get</span>([<span class="hljs-string">"name"</span>], <span class="hljs-literal">false</span>),ctx,<span class="hljs-string">"h"</span>).write(<span class="hljs-string">"!"</span>).exists(ctx.<span class="hljs-keyword">get</span>([<span class="hljs-string">"colors"</span>], <span class="hljs-literal">false</span>),ctx,{<span class="hljs-string">"block"</span>:body_1},<span class="hljs-literal">null</span>).notexists(ctx.<span class="hljs-keyword">get</span>([<span class="hljs-string">"colors"</span>], <span class="hljs-literal">false</span>),ctx,{<span class="hljs-string">"block"</span>:body_3},<span class="hljs-literal">null</span>);}<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">body_1</span><span class="hljs-params">(chk,ctx)</span>{</span><span class="hljs-keyword">return</span> chk.write(<span class="hljs-string">" &lt;ul&gt;"</span>).section(ctx.<span class="hljs-keyword">get</span>([<span class="hljs-string">"colors"</span>], <span class="hljs-literal">false</span>),ctx,{<span class="hljs-string">"block"</span>:body_2},<span class="hljs-literal">null</span>).write(<span class="hljs-string">"&lt;/ul&gt;"</span>);}<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">body_2</span><span class="hljs-params">(chk,ctx)</span>{</span><span class="hljs-keyword">return</span> chk.write(<span class="hljs-string">"&lt;li class=\"color\"&gt;"</span>).reference(ctx.getPath(<span class="hljs-literal">true</span>, []),ctx,<span class="hljs-string">"h"</span>).write(<span class="hljs-string">"&lt;/li&gt;"</span>);}<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">body_3</span><span class="hljs-params">(chk,ctx)</span>{</span><span class="hljs-keyword">return</span> chk.write(<span class="hljs-string">"&lt;div&gt;No colors!&lt;/div&gt;"</span>);}<span class="hljs-keyword">return</span> body_0;})();
</code></pre>
<p>Example compiled output for Raptor:</p>
<pre><code class="lang-javascript">module.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span><span class="hljs-params">(__helpers)</span> {</span>
  <span class="hljs-keyword">var</span> <span class="hljs-keyword">empty</span> = __helpers.e,
      notEmpty = __helpers.ne,
      escapeXml = __helpers.x,
      <span class="hljs-keyword">forEach</span> = __helpers.f;

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">(data, context)</span> {</span>
    context.w(<span class="hljs-string">'Hello '</span> +
      escapeXml(data.name) +
      <span class="hljs-string">'! '</span>);

    <span class="hljs-keyword">if</span> (notEmpty(data.colors)) {
      context.w(<span class="hljs-string">'&lt;ul&gt;'</span>);

      <span class="hljs-keyword">forEach</span>(data.colors, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(color)</span> {</span>
        context.w(<span class="hljs-string">'&lt;li class="color"&gt;'</span> +
          escapeXml(color) +
          <span class="hljs-string">'&lt;/li&gt;'</span>);
      });

      context.w(<span class="hljs-string">'&lt;/ul&gt;'</span>);
    }
    <span class="hljs-keyword">else</span> {
      context.w(<span class="hljs-string">'&lt;div&gt;No colors!&lt;/div&gt;'</span>);
    }
  };
}
</code></pre>
<p><strong>Winner: ✓ Raptor</strong></p>
<h2 id="security"><a name="security" class="anchor" href="#security"><span class="header-link"></span></a>Security</h2><div class="compare">
    <div class="col1 good">
        <h1>Dust</h1>
        <ul>
            <li>Automatic HTML escaping of dynamic text (enabled by default)</li>
            <li>Does not allow arbitrary JavaScript code to be embedded in a template</li>
            <li>Templates are guaranteed to be safe</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Automatic HTML escaping of dynamic text (enabled by default)</li>
            <li>Allows arbitrary JavaScript code to be embedded in a template</li>
        </ul>
    </div>
</div>

<p>Raptor Templates does allow arbitrary JavaScript code to be used inside templates (all expressions in Raptor templates are JavaScript). For this reason, it would not be appropriate to render untrusted Raptor templates provided by a third-party (at least without sandboxing at a higher level). In comparision, expressions in Dust are interpretted at runtime and this approach does not allow arbitrary JavaScript code to be embedded in a template.</p>
<p><strong>Winner:</strong> </p>
<ul>
<li><strong>✓ Raptor or Dust</strong>, if all templates are trusted (e.g. developed in-house)</li>
<li><strong>✓ Dust</strong>, if you are rendering untrusted templates (<em>rare for most use cases</em>)</li>
</ul>
<h2 id="validation"><a name="validation" class="anchor" href="#validation"><span class="header-link"></span></a>Validation</h2><div class="compare">
    <div class="col1 bad">
        <h1>Dust</h1>
        <ul>
            <li>Only syntax is checked at compile time</li>
            <li>Parameters passed to helper tags are not validated at compile time</li>
            <li>Silently discards helper tags that it does not recognize</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Attributes passed to custom tags are validated at compile time</li>
            <li>Better type handling</li>
            <li>Custom code can easily be used to validate template structure at compile-time</li>
            <li>HTML parser can easily be used to analyze templates</li>
        </ul>
    </div>
</div>

<p>As an example, the following code declares a simple custom tag for Raptor, along with allowed attributes:</p>
<pre><code class="lang-javascript">{
    "<span class="hljs-attribute">tags</span>": <span class="hljs-value">{
        "<span class="hljs-attribute">my-hello</span>": <span class="hljs-value">{
            "<span class="hljs-attribute">attributes</span>": <span class="hljs-value">{
                "<span class="hljs-attribute">name</span>": <span class="hljs-value"><span class="hljs-string">"string"</span></span>,
                "<span class="hljs-attribute">age</span>": <span class="hljs-value"><span class="hljs-string">"integer"</span>
            </span>}
        </span>}
    </span>}
</span>}
</code></pre>
<p>The following template will be successfully compiled:</p>
<pre><code class="lang-html">&lt;<span class="hljs-keyword">my</span>-hello <span class="hljs-property">name</span>=<span class="hljs-string">"Frank"</span> age=<span class="hljs-string">"20"</span>/&gt;
</code></pre>
<p>However, the following template will result in an error during compilation:</p>
<pre><code class="lang-html">&lt;<span class="hljs-keyword">my</span>-hello <span class="hljs-property">name</span>=<span class="hljs-string">"Frank"</span> gender=<span class="hljs-string">"male"</span>/&gt;
</code></pre>
<p>Error message:</p>
<pre><code><span class="hljs-attribute">Error</span>: <span class="hljs-string">Errors in template:</span>

<span class="vbnet"><span class="hljs-number">1</span>) [test-project/<span class="hljs-keyword">custom</span>-tag.rhtml:<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] The tag <span class="hljs-string">"my-hello"</span> <span class="hljs-keyword">in</span> taglib <span class="hljs-string">"test-project/raptor-taglib.json"</span> does <span class="hljs-keyword">not</span> support attribute <span class="hljs-string">"gender"</span> (&lt;test-hello&gt;)</span>
</code></pre><p><em>NOTE: With Raptor, declaring allowed attributes is an optional feature. As a custom tag developer, you can choose to allow all attributes by omitting the <code>attributes</code> property or by using the special <code>&quot;*&quot;: &quot;string&quot;</code> attribute definition.</em></p>
<p><strong>Winner: ✓ Raptor</strong></p>
<h2 id="editor-support"><a name="editor-support" class="anchor" href="#editor-support"><span class="header-link"></span></a>Editor Support</h2><div class="compare">
    <div class="col1 bad">
        <h1>Dust</h1>
        <ul>
            <li>Editor support:
                <ul>
                    <li>emacs using <a href="http://web-mode.org/">web-mode</a></li>
                </ul>
            </li>
            <li>Code required to register custom helper tags</li>
            <li>No schema is attached to custom helper tags</li>
            <li>Proprietary and evolving AST</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Compatible with any HTML editor</li>
            <li>Tag completion, HTML validation and syntax highlighting for free</li>
            <li>Declarative custom tags and attributes enables plugin developers to provide better validation and auto-completion</li>
            <li>Custom taglibs are automatically discovered (no code required)</li>
            <li>Any HTML parser can be used to analyze a Raptor template</li>
        </ul>
    </div>
</div>

<p><strong>Winner: ✓ Raptor</strong></p>
<h2 id="community"><a name="community" class="anchor" href="#community"><span class="header-link"></span></a>Community</h2><div class="compare">
    <div class="col1 good">
        <h1>Dust</h1>
        <ul>
            <li>Strong community start</li>
            <li>LinkedIn has helped promote Dust</li>
            <li>Active developers on <a href="http://stackoverflow.com/tags/dust.js/">StackOverflow</a></li>
        </ul>
    </div>
    <div class="col2 bad">
        <h1>Raptor</h1>
        <ul>
            <li>Emerging templating language</li>
            <li>Used by only a few companies (including eBay)</li>
            <li>Not heavily promoted</li>
            <li>Questions will be answered in Google Groups <a href="https://groups.google.com/forum/#!forum/raptorjs">discussion forum</a></li>
        </ul>
    </div>
</div>

<p><strong>Winner: ✓ Dust</strong></p>
<h2 id="maturity"><a name="maturity" class="anchor" href="#maturity"><span class="header-link"></span></a>Maturity</h2><div class="compare">
    <div class="col1 good">
        <h1>Dust</h1>
        <ul>
            <li>Relatively mature</li>
            <li>Used in heavily trafficked websites</li>
            <li>Still being improved</li>
            <li>Lots of tests</li>
        </ul>
    </div>
    <div class="col2 decent">
        <h1>Raptor</h1>
        <ul>
            <li>Relatively mature</li>
            <li>Used in heavily trafficked websites</li>
            <li>
                Recent and significant improvements:
                <ul>
                    <li>Switched from XML to HTML</li>
                    <li>Dropped XML namespaces</li>
                    <li>Better Node.js compatibility</li>
                    <li>Switched to CommonJS modules for compiled output</li>
                    <li>Faster and lighter</li>
                </ul>
            </li>
            <li>Lots of tests</li>
            <li>Still being improved</li>

        </ul>
    </div>
</div>

<p><strong>Winner: ✓ Dust</strong></p>
<h2 id="documentation"><a name="documentation" class="anchor" href="#documentation"><span class="header-link"></span></a>Documentation</h2><div class="compare">
    <div class="col1 good">
        <h1>Dust</h1>
        <ul>
            <li>Fairly complete <a href="https://github.com/linkedin/dustjs/wiki/Dust-Tutorial">documentation</a></li>
            <li>Node.js and JavaScript API documentation lacking</li>
            <li>Poor examples in <a href="http://linkedin.github.io/dustjs/test/test.html">online testbed</a></li>
            <li>Documentation is on Wiki and not README file (no Pull Requests)</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Fairly complete <a href="https://github.com/raptorjs3/raptor-templates">documentation</a></li>
            <li>Documentation is in a <a href="https://github.com/raptorjs3/raptor-templates/blob/master/README.md">README.md</a> file</li>
            <li>Legacy online testbed needs to be migrated to new version</li>
        </ul>
    </div>
</div>

<p>Documentation for both Raptor and Dust could use some improvement in a few areas, but overall the documentation is pretty good for both.</p>
<p><strong>Winner: - Tie</strong></p>
<h2 id="future-relevancy"><a name="future-relevancy" class="anchor" href="#future-relevancy"><span class="header-link"></span></a>Future Relevancy</h2><div class="compare">
    <div class="col1 decent">
        <h1>Dust</h1>
        <ul>
            <li>Custom helper tags are very much tied to Dust</li>
            <li>Does not embrace custom HTML tags</li>
        </ul>
    </div>
    <div class="col2 good">
        <h1>Raptor</h1>
        <ul>
            <li>Web Components and custom tags are becoming more popular</li>
            <li>Raptor custom tags can be swapped out with Web Component custom tags</li>
            <li>Raptor custom tag renderers can be used to render a shadow DOM</li>
            <li>Very easy to extend at compile time and runtime</li>
            <li>Custom tags are not tied to Raptor Templates</li>
        </ul>
    </div>
</div>

<p>Custom tags are an exciting trend that allow authors to define their own HTML tags that encapsulate view and behavior. The emerging Web Components standard and Raptor both support custom tags. In addition, the popular AngularJS framework also supports custom tags (called directives). The difference between a Raptor custom tag and a Web Components custom tag is that a Raptor custom tag is expanded to HTML when rendered on either the server or the client and a Web Components custom tag is expanded to a shadow DOM at time of insertion into the DOM. Custom elements are a very natural fit for web development and that appears to be an industry trend. In addition, it is possible to use the renderer for a Raptor Templates custom tag to produce the shadow DOM for a Web Components custom tag.</p>
<p>Because Raptor also adopts custom tags, Raptor Template custom tags can be seamlessly swapped out with Web Component custom tags.</p>
<p>Lastly, Raptor is very extensible at compile time and render time. This allows almost any feature to be added to the language with no restrictions. For example, while Raptor doesn&#39;t support data binding out-of-the-box, it is feasible to introduce a custom taglib to support data binding. For example:</p>
<pre><code class="lang-html"><span class="hljs-subst">&lt;</span>div <span class="hljs-built_in">data</span><span class="hljs-attribute">-bind</span><span class="hljs-attribute">-text</span><span class="hljs-subst">=</span><span class="hljs-string">"someProperty"</span><span class="hljs-subst">&gt;&lt;</span>/div<span class="hljs-subst">&gt;</span>
<span class="hljs-subst">&lt;</span>ul<span class="hljs-subst">&gt;</span>
    <span class="hljs-subst">&lt;</span>li <span class="hljs-built_in">data</span><span class="hljs-attribute">-bind</span><span class="hljs-attribute">-for</span><span class="hljs-subst">=</span><span class="hljs-string">"color in colors"</span><span class="hljs-subst">&gt;</span><span class="hljs-variable">$color</span><span class="hljs-subst">&lt;</span>/li<span class="hljs-subst">&gt;</span>
<span class="hljs-subst">&lt;</span>/ul<span class="hljs-subst">&gt;</span>
</code></pre>
<p><strong>Winner: ✓ Raptor</strong></p>
<h2 id="summary"><a name="summary" class="anchor" href="#summary"><span class="header-link"></span></a>Summary</h2><p>If you made it this far you are either skimming to get a final thoughts or you really want to make a good decision when deciding to invest in a templating language (if not the former, thank you for reading!). Below is a table that summarizes the results in each category:</p>
<table class="markdown-table"><thead><tr>
<th>Category</th>
<th>Winner</th>
</tr>
</thead><tbody><tr>
<td>Readability</td>
<td>Raptor</td>
</tr>
<tr>
<td>Ramp-up Time</td>
<td>Raptor</td>
</tr>
<tr>
<td>JavaScript API Usability</td>
<td>Raptor</td>
</tr>
<tr>
<td>DRY</td>
<td>Raptor</td>
</tr>
<tr>
<td>Async and Streaming Support</td>
<td>Raptor</td>
</tr>
<tr>
<td>Interoperability</td>
<td>It depends (<a href="#interoperability"><em>see notes</em></a>)</td>
</tr>
<tr>
<td>Extensibility</td>
<td>Raptor</td>
</tr>
<tr>
<td>Rendering Performance</td>
<td>Raptor</td>
</tr>
<tr>
<td>Page Weight</td>
<td>Raptor</td>
</tr>
<tr>
<td>Ease of Debugging</td>
<td>Raptor</td>
</tr>
<tr>
<td>Security</td>
<td>It depends (<a href="#security"><em>see notes</em></a>)</td>
</tr>
<tr>
<td>Validation</td>
<td>Raptor</td>
</tr>
<tr>
<td>Editor Support</td>
<td>Raptor</td>
</tr>
<tr>
<td>Community</td>
<td>Dust</td>
</tr>
<tr>
<td>Maturity</td>
<td>Dust</td>
</tr>
<tr>
<td>Documentation</td>
<td>Tie</td>
</tr>
<tr>
<td>Future Relevancy</td>
<td>Raptor</td>
</tr>
</tbody></table><p>My obvious preference is for Raptor Templates. As with all newer technologies, I had the chance to look at the current landscape and find room for improvement. While templating languages might seem like a solved problem, I think you will find the innovation that is part of Raptor Templates refreshing. Adopting Raptor Templates may require a shift in mindset, but I think the investment will be rewarding given the gaining popularity of custom tags and HTML-based templating languages.</p>
<p> Raptor Templates is being used at eBay and other companies and it is continuing to evolve. I encourage you to join the community and help make Raptor Templates the templating language of choice for more developers.</p>
]]></description>
            <content:encoded/>
            <author>
                <name>Patrick Steele-Idem</name>
                <email>pnidem@gmail.com</email>
            </author>
        </item>
        <item>
            <title><![CDATA[Introduction]]></title>
            <link>/intro/</link>
            <guid>/intro/</guid>
            <pubDate>Wed, 23 Apr 2014 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>Creating a blog is something I have meant to do for awhile now, but every time I tried to use an existing solution I would be overwhelmed by the urge to create my own blogging platform. I did not want to use a blogging platform that puts restrictions on how I format my website, or for my content to reside in some private database in some proprietary format. I knew I wanted to use a static website generator based on Node.js and Markdown, but when looking at the available options (and there were <a href="http://staticsitegenerators.net/">a lot of them</a>) I found too many restrictions. Which leads to the next topic: I rarely choose the easiest solution if I believe that there is a better solution waiting to be discovered. It took me a little longer to get going, but now I have a website and have introduced a new open source static site generator named <a href="https://github.com/patrick-steele-idem/freeze">Freeze</a>.</p>
<p>A little about myself, I’m currently a Senior Platform Architect at eBay. I started out building web applications, but I now focus mostly on building the platform so that others can build applications more easily. Building frameworks, platforms and tools is a much better fit for me because if I were tasked with building a web application I would typically end up spending too much time on the underlying architecture. </p>
<p>This blog gives me a chance to share my vision for how building web applications can be made easier. I am an open source advocate and you can find many of my projects linked to from this site.</p>
]]></description>
            <content:encoded/>
            <author>
                <name>Patrick Steele-Idem</name>
                <email>pnidem@gmail.com</email>
            </author>
        </item>
    </channel>
</rss>